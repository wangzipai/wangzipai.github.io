<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[断言]]></title>
    <url>%2Fposts%2F58240%2F</url>
    <content type="text"><![CDATA[​ 阅读GPIO_Init源码时，发现断言函数 assert，如下： 1234/* Check the parameters */assert_param(IS_GPIO_ALL_PERIPH(GPIOx));assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin)); ​ 为了能深入的理解断言在程序运行中的作用，我尝试对断言进行总结。在使用C语言编写工程代码时，我们总会对某种假设条件进行检查，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。然而assert并不仅仅是一个报错函数，事实上它还是一个宏。 ​ 断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新起用断言。它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题可以用断言来进行定位，从而缩短软件问题定位时间，提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。 ​ 原型定义：void assert( int expression ); ​ assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式 expression ，如果expression的值为假（即为0），那么它首先打印一条出错信息，然后通过调用abort 来终止程序运行。下面来看看一段代码： 1234567891011#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int main( void )&#123; int i; i=1; assert(i++); printf(&quot;%d\n&quot;,i); return 0;&#125; ​ 因为我们给定的i初始值为1，所以使用assert(i++);语句的时候不会出现错误，进而执行了i++，所以其后的打印语句输出值为2。如果我们把i的初始值改为0，那么就回出现如下错误。Assertion failed: i++, file E:\fdsa\assert2.cpp, line 8Press any key to continue ​ 断言语句不是永远会执行，可以屏蔽也可以启用，这就要求assert不管是在屏蔽还是启用的情况下都不能对我们本身代码的功能有所影响，这样的话刚才我们在代码中使用了一句assert(i++);是不妥的，因为我们一旦禁用了assert，i++的语句就得不到执行，对于接下来i值的使用就会出现问题了，所以对于这样的语句我们应该是要分开来实现，写出如下两句来替代， assert(i); i++;，所以这就对于断言的使用有了相应的要求，那么我们一般在什么情况下使用断言呢？主要体现在一下几个方面： ​ 1.可以在预计正常情况下程序不会到达的地方放置断言。（如assert (0);） ​ 2.使用断言测试方法执行的前置条件和后置条件 。 ​ 3.使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如某个变量的变化范围） ​ 对于上面的前置条件和后置条件可能有的读者还不是很了解，那么看看下面的解释你就明白了。 ​ 1.前置条件断言：代码执行之前必须具备的特性 ​ 2.后置条件断言：代码执行之后必须具备的特性 ​ 3.前后不变断言：代码执行前后不能变化的特性 ​ 当然在使用的断言的过程中会有一些我们应该注意的事项和养成一些良好的习惯，如： ​ 1.每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，我们就无法直观的判断是哪个条件失败 ​ 2.不能使用改变环境的语句，就像我们上面的代码改变了i变量，在实际编写代码的过程中是不能这样做的 ​ 3.assert和后面的语句应空一行，以形成逻辑和视觉上的一致感，也算是一种良好的编程习惯吧，让编写的代码有一种视觉上的美感 ​ 4.有的地方，assert不能代替条件过滤 ​ 5.放在函数参数的入口处检查传入参数的合法性 ​ 6.断言语句不可以有任何边界效应 ​ 7.频繁的调用会极大的影响程序的性能，增加额外的开销。所以在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用。 ​ 现在回到GPIO_Init源码中，通过以下2段代码我们可以更好的理解断言在实际开发中的应用 1assert_param(IS_GPIO_ALL_PERIPH(GPIOx)); 1234567#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \ ((PERIPH) == GPIOB) || \ ((PERIPH) == GPIOC) || \ ((PERIPH) == GPIOD) || \ ((PERIPH) == GPIOE) || \ ((PERIPH) == GPIOF) || \ ((PERIPH) == GPIOG)) ​ 由第二段代码的含参宏，确定传入的参数是否符合要求，这种用法为上述的前置条件断言。]]></content>
      <tags>
        <tag>C语言</tag>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[前言本来想把这个初始化的界面删了，后来想想算了，干脆用这个界面来记录建立博客的经过，方便以后参考。 由于这两天的建站，严重影响自学的进度，就主要记录一些采过的坑吧。 参考教程基础使用Hexo+Github一步步搭建属于自己的博客（基础） 使用Hexo+Github一步步搭建属于自己的博客（进阶） 进阶打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 hexo的next主题个性化配置教程 内容博文压缩教程在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 进入博客根目录，新建gulpfile.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 填坑然而，运行 hexo g &amp;&amp; gulp 时，会出现以下错误： 123456789101112131415assert.js:350 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (D:\nodejs\blog\node_modules\undertaker\lib\set-task.js:10:3) at Gulp.task (D:\nodejs\blog\node_modules\undertaker\lib\task.js:13:8) at Object.&lt;anonymous&gt; (D:\nodejs\blog\gulpfile.js:31:6) at Module._compile (internal/modules/cjs/loader.js:701:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10) at Module.load (internal/modules/cjs/loader.js:600:32) at tryModuleLoad (internal/modules/cjs/loader.js:539:12) at Function.Module._load (internal/modules/cjs/loader.js:531:3) at Module.require (internal/modules/cjs/loader.js:637:17) at require (internal/modules/cjs/helpers.js:22:18) gulp项目需要全局安装gulp和项目内安装gulp，通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 123$ gulp -v[22:12:41] CLI version 2.0.1[22:12:41] Local version 4.0.0 查看项目里的D:\nodejs\blog\package.json文件，可以看到gulp版本 12345678910111213&quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;del&quot;: &quot;^4.0.0&quot;, &quot;gulp&quot;: &quot;^4.0.1&quot;, &quot;gulp-babel&quot;: &quot;^8.0.0&quot;, &quot;gulp-clean-css&quot;: &quot;^4.0.0&quot;, &quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;, &quot;gulp-htmlmin&quot;: &quot;^5.0.1&quot;, &quot;gulp-imagemin&quot;: &quot;^5.0.3&quot;, &quot;gulp-uglify&quot;: &quot;^3.0.2&quot;, &quot;run-sequence&quot;: &quot;^2.2.1&quot; &#125; 将 &quot;gulp&quot;: &quot;^4.0.1&quot;,改成 &quot;gulp&quot;: &quot;^2.0.1&quot;,发现出现错误Unsupported gulp version 将版本号从gulp2改成改成gulp3&quot;gulp&quot;: &quot;^2.0.1&quot;，成功。 鼠标飘字特效教程新建一个js：*/themes/next/source/js/src/jiazhiguan.js 12345678910111213141516171819202122232425262728/* 鼠标飘字*/var a_idx = 0;jQuery(document).ready(function($) &#123;$(&quot;body&quot;).click(function(e) &#123;var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot; ,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);a_idx = (a_idx + 1) % a.length;var x = e.pageX,y = e.pageY;$i.css(&#123;&quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999,&quot;top&quot;: y - 20,&quot;left&quot;: x,&quot;position&quot;: &quot;absolute&quot;,&quot;font-weight&quot;: &quot;bold&quot;,&quot;color&quot;: &quot;#a40000&quot;&#125;);$(&quot;body&quot;).append($i);$i.animate(&#123;&quot;top&quot;: y - 180,&quot;opacity&quot;: 0&#125;,1500,function() &#123;$i.remove();&#125;);&#125;);&#125;); 然后在Blog\themes\next\layout\_layout.swig文件的最下方，&lt;/body&gt;前面添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/jiazhiguan.js&quot;&gt;&lt;/script&gt;。 填坑由于ANSI编码无中文字符，所以出现乱码。将编码从ANSI改成utf-8编码。 用记事本打开这个1.html，把这文档另存到原来的目录，覆盖自己，只是编码要从ANSI改成utf-8。完成。 待续。。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
