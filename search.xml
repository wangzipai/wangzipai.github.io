<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[stm32蜂鸣器实验总结]]></title>
    <url>%2Fposts%2F31496%2F</url>
    <content type="text"><![CDATA[由于家境贫寒只买得起mini版的缘故，关于蜂鸣器的实验只能另外买蜂鸣器外设来做实验了。也因此蜂鸣器所使用的IO口可以自定义，并不一定只能用PB.8来做实验。实验中出现了一些小问题，记录下来，以便之后的复习。 首先是在写beef.c的时候，变量的声明放在了可执行语句的后面。 12345678910111213141516#include "beep.h"#include "stm32f10x.h"void BEEP_Init(void)&#123; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB,&amp;GPIO_InitStructure); GPIO_ResetBits(GPIOB,GPIO_Pin_8); &#125; 使用MDK调试的时候，出现以下错误： error: #268: declaration may not appear after executablestatement 修改为： 12345678910111213141516#include "beep.h"#include "stm32f10x.h"void BEEP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB,&amp;GPIO_InitStructure); GPIO_ResetBits(GPIOB,GPIO_Pin_8); &#125; 编译通过。 第二个错误是误把RCC_APB2PeriphClockCmd写成RCC_APB2PeriphResetCmd，由于这两个函数前后一样，且RCC_APB2PeriphResetCmd函数在更显眼的地方，以后要注意。 接下来是关于蜂鸣器实验的一些总结。 蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电。STM32 开发板板载的蜂鸣器是电磁式的有源蜂鸣器。这里的有源不是指电源的“源”，而是指有没有自带震荡电路，有源蜂鸣器自带了震荡电路，一通电就会发声；无源蜂鸣器则没有自带震荡电路，必须外部提供2~5Khz 左右的方波驱动，才能发声。 STM32 的单个 IO 最大可以提供 25mA 电流（来自数据手册），而蜂鸣器的驱动电流是 30mA 左右，两者十分相近，但是全盘考虑，STM32 整个芯片的电流，最大也就 150mA，如果用 IO 口直接驱动蜂鸣器，其他地方用电就得省着点了…所以，我们不用 STM32 的 IO 直接驱动蜂鸣器，而是通过三极管扩流后再驱动蜂鸣器，这样STM32 的 IO 只需要提供不到 1mA 的电流就足够了。 蜂鸣器与 STM32 连接原理图 ： 图中我们用到一个 NPN 三极管（S8050）来驱动蜂鸣器，R38 主要用于防止蜂鸣器的误发声。当 PB.8 输出高电平的时候，蜂鸣器将发声，当 PB.8 输出低电平的时候，蜂鸣器停止发声。]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32的3种开发方式]]></title>
    <url>%2Fposts%2F31616%2F</url>
    <content type="text"><![CDATA[前言stm32有3种不同的开发方式，库函数开发，基于寄存器开发与位带操作。3种方式各有优劣，这里我简单的写一下自己的看法吧。 在51单片机的程序开发中，我们直接配置寄存器。因为51的功能相对比较简单，对应的寄存器也比较少，所以可以通过配置寄存器的方式开发。到了stm32中，虽然原理相同，但功能多了非常多，寄存器也相对的多了，这时想象51一样记住每个寄存器是不可能的。这时ST公司提供了库函数，开发者只需调用这些函数接口来配置寄存器。 而这3种方式，本质上都是通过不同的途径，最终实现对相应寄存器的配置。 基于寄存器开发直接配置寄存器，可以更直观的了解配置的是那些寄存器以及是如何配置的，同时运行程序是占用资源也更少，代码更加简洁。 1234567891011121314void LED_Init(void)&#123; RCC-&gt;APB2ENR|=1&lt;&lt;2; RCC-&gt;APB2ENR|=1&lt;&lt;5; //GPIOA.8 GPIOA-&gt;CRH&amp;=0XFFFFFFF0; GPIOA-&gt;CRH|=0X00000003; GPIOA-&gt;ODR|=1&lt;&lt;8; //GPIOD.2 GPIOD-&gt;CRL&amp;=0XFFFFF0FF; GPIOD-&gt;CRL|=0X00000300; GPIOD-&gt;ODR|=1&lt;&lt;2;&#125; 这样的方式是内核执行效率最高的方式，然而由于寄存器数量和复杂度的增加，直接配置寄存器的开发速度和程序可读性就下降。 库函数开发库的本质就是建立一个新的软件抽象层，分层使得问题变得简单，屏蔽了底层实现方式的差异，让软件开发变成简单的调用函数。 从内核的执行效率来看，首先库函数在被调用的时候，要耗费调用的时间，在函数内部，把输入参数转换成直接写入到寄存器的值也耗费了一些运算时间。优点是可以快速上手stm32微控制器，交流方便，查错简单。 123456789101112131415161718void LED_Init (void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD,ENABLE); GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_8; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStructure); GPIO_SetBits(GPIOA,GPIO_Pin_8); GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOD,&amp;GPIO_InitStructure); GPIO_SetBits(GPIOD,GPIO_Pin_2); &#125; 位带操作（记得引入sys.h头文件）原理把每个比特膨胀为一个32位的字，当访问这些字的时候就达到了访问比特的目的，比如说BSRR寄存器有32个位，那么可以映射到32个地址上，我们去访问（读-改-写）这32个地址就达到访问32个比特的目的。 优点对硬件I/O密集型的底层程序提供了很大方便，使代码更加简洁。化简跳转的判断。在多任务中实现共享资源在任务间的“互锁”访问。 支持区域其中一个是 SRAM 区的最低 1MB 范围，0x20000000 ‐ 0x200FFFFF（SRAM 区中的最低 1MB） 第二个则是片内外设区的最低 1MB范围，0x40000000 ‐ 0x400FFFFF（片上外设区中最低 1MB） 123456789101112131415161718#define LED0 PAout(8) // PA8#define LED1 PDout(2) // PD2 int main(void)&#123; Stm32_Clock_Init(9); //系统时钟设置 delay_init(72); //延时初始化 LED_Init(); //初始化与LED连接的硬件接口 while(1) &#123; LED0=0; LED1=1; delay_ms(300); LED0=1; LED1=0; delay_ms(300); &#125; &#125; 最后随着处理器性能的不断提升，库函数开发会成为趋势，但寄存器可以对原理有更深入的了解。库和寄存器交叉学习，开发用库，然后慢慢深入，加深理解。]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客的玄学加速]]></title>
    <url>%2Fposts%2F50535%2F</url>
    <content type="text"><![CDATA[前言利用 InstantClick、hexo-service-worker、hexo-filter-optimize 加速博客 InstantClickInstantClick是一个JavaScript库，可以通过预加载显着加快网站的速度。先下载压缩版的 instantclick.min.js（浏览器右键保存为），再放到~/next/source/js/src/下，然后添加代码： 12&lt;script type="text/javascript" src= "/js/src/instantclick.min.js" data-no-instant&gt;&lt;/script&gt;&lt;script data-no-instant&gt;InstantClick.init();&lt;/script&gt; 去除顶部加载条： 在next/source/css/_custom/custom.styl文件添加以下代码： 123#instantclick &#123; display: none;&#125; hexo-service-workerhexo-service-worker 是一个 hexo 用来让博客拥有 Service Worker 功能的插件，能够默认的把站点中 public 内的所有静态资源包括 html 文件缓存起来，达到离线可访问的效果 安装1npm i hexo-service-worker --save 用法安装插件后，直接配置 _config.yml 文件如下就可以了： 1234567# offline config passed to sw-precache.service_worker: maximumFileSizeToCacheInBytes: 5242880 staticFileGlobs: - public/**/*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125; stripPrefix: public verbose: true hexo-filter-optimize安装1npm install hexo-filter-optimize --save 用法安装插件后，直接配置 _config.yml 文件如下就可以了： 12345678910111213141516171819202122232425filter_optimize: enable: true # remove static resource query string # - like `?v=1.0.0` remove_query_string: true # remove the surrounding comments in each of the bundled files remove_comments: false css: enable: true # bundle loaded css file into the one bundle: true # use a script block to load css elements dynamically delivery: true # make specific css content inline into the html page # - only support the full path # - default is ['css/main.css'] inlines: excludes: js: # bundle loaded js file into the one bundle: true excludes: # set the priority of this plugin, # lower means it will be executed first, default is 10 priority: 12 修复网页图标不显示在主题配置文件中，让fontawesome 使用 cdn 即可，搜索fontawesome，修改如下： 123# Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: http://maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPIO_Init源码及注释]]></title>
    <url>%2Fposts%2F53676%2F</url>
    <content type="text"><![CDATA[GPIO_Init源码及注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)//把GPIOx的地址转换为GPIO_TypeDef结构体指针类型&#123; uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00; uint32_t tmpreg = 0x00, pinmask = 0x00; /* 断言，用于检查输入的参数是否正确 */ assert_param(IS_GPIO_ALL_PERIPH(GPIOx)); assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode)); assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin)); /*---------------------------- GPIO的模式配置 -----------------------*//*把输入参数GPIO_Mode的低四位暂存在currentmode*/ currentmode = ((uint32_t)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((uint32_t)0x0F);/*判断是否为输出模式，若是输出模式，可输入参数中输出模式的bit4位都是1typedef enum&#123; GPIO_Mode_AIN = 0x0, GPIO_Mode_IN_FLOATING = 0x04, GPIO_Mode_IPD = 0x28, GPIO_Mode_IPU = 0x48, GPIO_Mode_Out_OD = 0x14, GPIO_Mode_Out_PP = 0x10, GPIO_Mode_AF_OD = 0x1C, GPIO_Mode_AF_PP = 0x18&#125;GPIOMode_TypeDef;*/ if ((((uint32_t)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((uint32_t)0x10)) != 0x00) &#123; /* 检查输入参数 */ assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed)); /* 输出模式，所以要配置GPIO的速率（00（输入模式） 01（10MHz）） 10（2MHz） 11(20MHz) */ currentmode |= (uint32_t)GPIO_InitStruct-&gt;GPIO_Speed; &#125;//GPIO_Mode的低四位分别为0000，0100，1000，1100.对速率无影响/*---------------------------- 配置GPIO的CRL寄存器 ------------------------*/ /* 判断要配置的是否为pin0~pin7*//*#define GPIO_Pin_0 ((uint16_t)0x0001) /*!&lt; Pin 0 selected */#define GPIO_Pin_1 ((uint16_t)0x0002) /*!&lt; Pin 1 selected */#define GPIO_Pin_2 ((uint16_t)0x0004) /*!&lt; Pin 2 selected */#define GPIO_Pin_3 ((uint16_t)0x0008) /*!&lt; Pin 3 selected */#define GPIO_Pin_4 ((uint16_t)0x0010) /*!&lt; Pin 4 selected */#define GPIO_Pin_5 ((uint16_t)0x0020) /*!&lt; Pin 5 selected */#define GPIO_Pin_6 ((uint16_t)0x0040) /*!&lt; Pin 6 selected */#define GPIO_Pin_7 ((uint16_t)0x0080) /*!&lt; Pin 7 selected */#define GPIO_Pin_8 ((uint16_t)0x0100) /*!&lt; Pin 8 selected */#define GPIO_Pin_9 ((uint16_t)0x0200) /*!&lt; Pin 9 selected */#define GPIO_Pin_10 ((uint16_t)0x0400) /*!&lt; Pin 10 selected*/#define GPIO_Pin_11 ((uint16_t)0x0800) /*!&lt; Pin 11 selected*/#define GPIO_Pin_12 ((uint16_t)0x1000) /*!&lt; Pin 12 selected*/#define GPIO_Pin_13 ((uint16_t)0x2000) /*!&lt; Pin 13 selected*/#define GPIO_Pin_14 ((uint16_t)0x4000) /*!&lt; Pin 14 selected*/#define GPIO_Pin_15 ((uint16_t)0x8000) /*!&lt; Pin 15 selected*/#define GPIO_Pin_All ((uint16_t)0xFFFF) /*!&lt; All pins selected */ */ if (((uint32_t)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((uint32_t)0x00FF)) != 0x00) &#123; /*备份原CRL寄存器的值*/ tmpreg = GPIOx-&gt;CRL; /*循环，一个循环设置一个寄存器位*/ for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++) &#123; /*pos的值为1左移pinpos位*/ pos = ((uint32_t)0x01) &lt;&lt; pinpos; /* 令pos与输入参数GPIO_PIN做位与运算，为下面的判断做准备 */ currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos; /*判断，若currentpin等于pos，说明GPIO_PIN参数中含的第pos个引脚需要配置*/ if (currentpin == pos) &#123; /*pos的值左移2位（乘以4），因为寄存器中4个寄存器位配置一个引脚*/ pos = pinpos &lt;&lt; 2; /*以下两个句子，把控制这个引脚的4个寄存器位清零，其他寄存器位不变*/ /* Clear the corresponding low control register bits */ pinmask = ((uint32_t)0x0F) &lt;&lt; pos; tmpreg &amp;= ~pinmask; /* 向寄存器写入将要配置的引脚模式 */ tmpreg |= (currentmode &lt;&lt; pos); /* 复位GPIO引脚的输入输出默认值 */ /* 判断是否为下拉输入模式 */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD) &#123; /*下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置零*/ GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; pinpos); &#125; else &#123; /* 判断是否为上拉输入模式 */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU) &#123; /*上拉输入模式，引脚默认置1，对BSRR寄存器写1可对引脚置1*/ GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; pinpos); &#125; &#125; &#125; &#125; /*把前面处理后的暂存值写入CRL寄存器之中*/ GPIOx-&gt;CRL = tmpreg; &#125;/*---------------------------- GPIO CRH Configuration ------------------------*/ /* Configure the eight high port pins */ if (GPIO_InitStruct-&gt;GPIO_Pin &gt; 0x00FF) &#123; tmpreg = GPIOx-&gt;CRH; for (pinpos = 0x00; pinpos &lt; 0x08; pinpos++) &#123; pos = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08)); /* Get the port pins position */ currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos); if (currentpin == pos) &#123; pos = pinpos &lt;&lt; 2; /* Clear the corresponding high control register bits */ pinmask = ((uint32_t)0x0F) &lt;&lt; pos; tmpreg &amp;= ~pinmask; /* Write the mode configuration in the corresponding bits */ tmpreg |= (currentmode &lt;&lt; pos); /* Reset the corresponding ODR bit */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD) &#123; GPIOx-&gt;BRR = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08)); &#125; /* Set the corresponding ODR bit */ if (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU) &#123; GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; (pinpos + 0x08)); &#125; &#125; &#125; GPIOx-&gt;CRH = tmpreg; &#125;&#125;]]></content>
      <tags>
        <tag>stm32</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32 I/O口的八种工作模式]]></title>
    <url>%2Fposts%2F33448%2F</url>
    <content type="text"><![CDATA[stm32 I/O口有8种工作模式，分别为4种输入模式和4种输出模式： 4种输入模式： 1234（1）GPIO_Mode_AIN 模拟输入 （2）GPIO_Mode_IN_FLOATING 浮空输入 （3）GPIO_Mode_IPD 下拉输入 （4）GPIO_Mode_IPU 上拉输入 4种输出模式： 1234（5）GPIO_Mode_Out_OD 开漏输出 （6）GPIO_Mode_Out_PP 推挽输出 （7）GPIO_Mode_AF_OD 复用开漏输出 （8）GPIO_Mode_AF_PP 复用推挽输出 那么这8种工作模式具体的含义是什么呢？ 浮空,顾名思义就是浮在空中,上面用绳子一拉就上去了,下面用绳子一拉就沉下去了. 开漏,就等于输出口接了个NPN三极管,并且只接了e,b. c极 是开路的,你可以接一个电阻到3.3V,也可以接一个电阻到5V,这样,在输出1的时候,就可以是5V电压,也可以是3.3V电压了.但是不接电阻上拉的时候,这个输出高就不能实现了. 推挽,就是有推有拉,任何时候IO口的电平都是确定的,不需要外接上拉或者下拉电阻. 推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中,各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。输出高电平的时候，P-MOS管导通。低电平时，N-MOS管导通。两个管子轮流导通，一个负责灌电流，一个负责拉电流 ，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的供电平为0伏，高电平为3.3伏。 开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。如果我们控制输出为0，低电平，则N-MOS管导通，使输出接地。若控制输出为1，则既不输出高电平，也不输出低电平，为高阻态，需外接一个上拉电阻。他具有“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接电源的电压。若其中一个引脚为低电平，那线路就相当于短路接地，使得整个线路都为低电平，0伏。开漏形式的电路有以下几个特点： 利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。 一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的沿的速度 。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。） OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。 可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。 补充：什么是“线与”？： 在一个结点(线)上, 连接一个上拉电阻到电源 VCC 或 VDD 和 n 个 NPN 或 NMOS 晶体管的集电极 C 或漏极 D, 这些晶体管的发射极 E 或源极 S 都接到地线上, 只要有一个晶体管饱和, 这个结点(线)就被拉到地线电平上. 因为这些晶体管的基极注入电流(NPN)或栅极加上高电平(NMOS),晶体管就会饱和, 所以这些基极或栅极对这个结点(线)的关系是或非 NOR 逻辑. 如果这个结点后面加一个反相器, 就是或 OR 逻辑. 其实可以简单的理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。 推挽输出模式一般应用在输出电平为0和3.3伏的场合。而开漏输出模式一般应用在电平不匹配的场合，如需要输出5伏的电压。 浮空输入模式在芯片内部既没有接上拉，也没有接下拉电阻，经由触发器输入。配置成这个模式直接用电压表测量其引脚电压为1点几伏，是个不确定值。由于其输入阻抗较大，一般把这种模式用于标准的通信协议如I2C，USART的接收端。由于浮空输入一般多用于外部按键输入，浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。 上拉输入/下拉输入/模拟输入：这几个概念很好理解，从字面便能轻易读懂。 若配置为上拉输入模式，默认情况下（GPIO引脚无输入），读取的GPIO引脚数据为1，高电平。下拉输入模式则相反，在默认情况下其引脚数据为0，低电平。 模拟输入模式则关闭了施密特触发器，不接上下拉电阻，经由另一线路把电压信号传送到片上外设模块。如传送至ADC模块，由ADC模块采集电压信号。所以采用ADC外设的时候，必须使用模拟输入模式。 复用开漏输出、复用推挽输出：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）最后总结下使用情况：在STM32中选用IO模式（1） 浮空输入_IN_FLOATING ——浮空输入，可以做KEY识别，RX1（2）带上拉输入_IPU——IO内部上拉电阻输入（3）带下拉输入_IPD—— IO内部下拉电阻输入（4） 模拟输入_AIN ——应用ADC模拟输入，或者低功耗下省电（5）开漏输出_OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能（6）推挽输出_OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的（7）复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA）（8）复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）STM32设置实例：（1）模拟I2C使用开漏输出_OUT_OD，接上拉电阻，能够正确输出0和1；读值时先GPIO_SetBits(GPIOB, GPIO_Pin_0)；拉高，然后可以读IO的值；使用GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)；（2）如果是无上拉电阻，IO默认是高电平；需要读取IO的值，可以使用带上拉输入_IPU和浮空输入_IN_FLOATING和开漏输出_OUT_OD；]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断言]]></title>
    <url>%2Fposts%2F58240%2F</url>
    <content type="text"><![CDATA[​ 阅读GPIO_Init源码时，发现断言函数 assert，如下： 1234/* Check the parameters */assert_param(IS_GPIO_ALL_PERIPH(GPIOx));assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin)); ​ 为了能深入的理解断言在程序运行中的作用，我尝试对断言进行总结。在使用C语言编写工程代码时，我们总会对某种假设条件进行检查，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。然而assert并不仅仅是一个报错函数，事实上它还是一个宏。 ​ 断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新起用断言。它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题可以用断言来进行定位，从而缩短软件问题定位时间，提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。 ​ 原型定义：void assert( int expression ); ​ assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式 expression ，如果expression的值为假（即为0），那么它首先打印一条出错信息，然后通过调用abort 来终止程序运行。下面来看看一段代码： 1234567891011#include &lt;stdio.h&gt;#include &lt;assert.h&gt;int main( void )&#123; int i; i=1; assert(i++); printf("%d\n",i); return 0;&#125; ​ 因为我们给定的i初始值为1，所以使用assert(i++);语句的时候不会出现错误，进而执行了i++，所以其后的打印语句输出值为2。如果我们把i的初始值改为0，那么就回出现如下错误。Assertion failed: i++, file E:\fdsa\assert2.cpp, line 8Press any key to continue ​ 断言语句不是永远会执行，可以屏蔽也可以启用，这就要求assert不管是在屏蔽还是启用的情况下都不能对我们本身代码的功能有所影响，这样的话刚才我们在代码中使用了一句assert(i++);是不妥的，因为我们一旦禁用了assert，i++的语句就得不到执行，对于接下来i值的使用就会出现问题了，所以对于这样的语句我们应该是要分开来实现，写出如下两句来替代， assert(i); i++;，所以这就对于断言的使用有了相应的要求，那么我们一般在什么情况下使用断言呢？主要体现在一下几个方面： ​ 1.可以在预计正常情况下程序不会到达的地方放置断言。（如assert (0);） ​ 2.使用断言测试方法执行的前置条件和后置条件 。 ​ 3.使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如某个变量的变化范围） ​ 对于上面的前置条件和后置条件可能有的读者还不是很了解，那么看看下面的解释你就明白了。 ​ 1.前置条件断言：代码执行之前必须具备的特性 ​ 2.后置条件断言：代码执行之后必须具备的特性 ​ 3.前后不变断言：代码执行前后不能变化的特性 ​ 当然在使用的断言的过程中会有一些我们应该注意的事项和养成一些良好的习惯，如： ​ 1.每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，我们就无法直观的判断是哪个条件失败 ​ 2.不能使用改变环境的语句，就像我们上面的代码改变了i变量，在实际编写代码的过程中是不能这样做的 ​ 3.assert和后面的语句应空一行，以形成逻辑和视觉上的一致感，也算是一种良好的编程习惯吧，让编写的代码有一种视觉上的美感 ​ 4.有的地方，assert不能代替条件过滤 ​ 5.放在函数参数的入口处检查传入参数的合法性 ​ 6.断言语句不可以有任何边界效应 ​ 7.频繁的调用会极大的影响程序的性能，增加额外的开销。所以在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用。 ​ 现在回到GPIO_Init源码中，通过以下2段代码我们可以更好的理解断言在实际开发中的应用 1assert_param(IS_GPIO_ALL_PERIPH(GPIOx)); 1234567#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \ ((PERIPH) == GPIOB) || \ ((PERIPH) == GPIOC) || \ ((PERIPH) == GPIOD) || \ ((PERIPH) == GPIOE) || \ ((PERIPH) == GPIOF) || \ ((PERIPH) == GPIOG)) ​ 由第二段代码的含参宏，确定传入的参数是否符合要求，这种用法为上述的前置条件断言。]]></content>
      <tags>
        <tag>stm32</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107%2F</url>
    <content type="text"><![CDATA[前言本来想把这个初始化的界面删了，后来想想算了，干脆用这个界面来记录建立博客的经过，方便以后参考。 由于这两天的建站，严重影响自学的进度，就主要记录一些采过的坑吧。 参考教程基础使用Hexo+Github一步步搭建属于自己的博客（基础） 使用Hexo+Github一步步搭建属于自己的博客（进阶） 进阶打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 hexo的next主题个性化配置教程 内容博文压缩教程在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 进入博客根目录，新建gulpfile.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 填坑然而，运行 hexo g &amp;&amp; gulp 时，会出现以下错误： 123456789101112131415assert.js:350 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (D:\nodejs\blog\node_modules\undertaker\lib\set-task.js:10:3) at Gulp.task (D:\nodejs\blog\node_modules\undertaker\lib\task.js:13:8) at Object.&lt;anonymous&gt; (D:\nodejs\blog\gulpfile.js:31:6) at Module._compile (internal/modules/cjs/loader.js:701:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:712:10) at Module.load (internal/modules/cjs/loader.js:600:32) at tryModuleLoad (internal/modules/cjs/loader.js:539:12) at Function.Module._load (internal/modules/cjs/loader.js:531:3) at Module.require (internal/modules/cjs/loader.js:637:17) at require (internal/modules/cjs/helpers.js:22:18) gulp项目需要全局安装gulp和项目内安装gulp，通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 123$ gulp -v[22:12:41] CLI version 2.0.1[22:12:41] Local version 4.0.0 查看项目里的D:\nodejs\blog\package.json文件，可以看到gulp版本 12345678910111213"devDependencies": &#123; "babel-core": "^6.26.3", "babel-preset-es2015": "^6.24.1", "del": "^4.0.0", "gulp": "^4.0.1", "gulp-babel": "^8.0.0", "gulp-clean-css": "^4.0.0", "gulp-htmlclean": "^2.7.22", "gulp-htmlmin": "^5.0.1", "gulp-imagemin": "^5.0.3", "gulp-uglify": "^3.0.2", "run-sequence": "^2.2.1" &#125; 将 &quot;gulp&quot;: &quot;^4.0.1&quot;,改成 &quot;gulp&quot;: &quot;^2.0.1&quot;,发现出现错误Unsupported gulp version 将版本号从gulp2改成改成gulp3&quot;gulp&quot;: &quot;^2.0.1&quot;，成功。 鼠标飘字特效教程新建一个js：*/themes/next/source/js/src/jiazhiguan.js 12345678910111213141516171819202122232425262728/* 鼠标飘字*/var a_idx = 0;jQuery(document).ready(function($) &#123;$("body").click(function(e) &#123;var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正" ,"法治", "爱国", "敬业", "诚信", "友善");var $i = $("&lt;span/&gt;").text(a[a_idx]);a_idx = (a_idx + 1) % a.length;var x = e.pageX,y = e.pageY;$i.css(&#123;"z-index": 999999999999999999999999999999999999999999999999999999999999999999999,"top": y - 20,"left": x,"position": "absolute","font-weight": "bold","color": "#a40000"&#125;);$("body").append($i);$i.animate(&#123;"top": y - 180,"opacity": 0&#125;,1500,function() &#123;$i.remove();&#125;);&#125;);&#125;); 然后在Blog\themes\next\layout\_layout.swig文件的最下方，&lt;/body&gt;前面添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/jiazhiguan.js&quot;&gt;&lt;/script&gt;。 填坑由于ANSI编码无中文字符，所以出现乱码。将编码从ANSI改成utf-8编码。 用记事本打开这个1.html，把这文档另存到原来的目录，覆盖自己，只是编码要从ANSI改成utf-8。完成。 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在pace段后面插入这样一段代码： 1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 1234567title: 断言tags: - C语言 - stm32abbrlink: 58240date: 2019-03-17 23:10:42password: ******** 添加网页标题崩溃欺骗搞怪特效创建js文件 在 next\source\js\src 文件夹下创建 crash_cheat.js，添加代码如下： 1234567891011121314151617&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好了~' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 引用在 next\layout\_layout.swig 文件中，添加引用（注：在swig末尾添加）： 12&lt;!--崩溃欺骗--&gt;&lt;script type="text/javascript" src="/js/src/crash_cheat.js"&gt;&lt;/script&gt; 待续。。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
