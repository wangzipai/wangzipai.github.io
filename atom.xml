<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Santos</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangzipai.github.io/"/>
  <updated>2019-04-16T16:18:39.305Z</updated>
  <id>https://wangzipai.github.io/</id>
  
  <author>
    <name>wangyaoqin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言学习随笔</title>
    <link href="https://wangzipai.github.io/posts/48322/"/>
    <id>https://wangzipai.github.io/posts/48322/</id>
    <published>2019-04-16T15:53:05.000Z</published>
    <updated>2019-04-16T16:18:39.305Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+8Kya+TxzZ8HGucEo8WCdCDykl2Wxy6MldHeGGE4Vv5HJtUVbRj1cX0Z1Z3tNrGXCSV4nezt6cj/RqhLbQw0YHw9qtTfdqaue7ayLkXE79YWpFHFFMY4iLciCGwqPnY8XZ7FiALuuOu3yQ1VyPeI1jUjj1IgJRGLtjozNadoG1AZW9OgnlU+QNNkwRhy+uanIJbmHCY9J3KxH1OPmUI5Si0MlJ1EIPNz8/Sf/zonfVq7fF3orXlNhQ15cr2RA1PAUiZFbrPzw12OCo9HmNCyT1E+ltulyOWAuSFuLvnYjVH21TQg8KlJRlOUCjMkp6QHGtUV+pD4UxOLBkZTuzFHK7Kz+Cu+QP5OvhyacQdxLpPKUcVBJdBQ3lPk75/oyqS8AXDQGeogmVo0GO7ubUoZ00lH/UD0cZAM7cqLEuvsG2xLzl4L17H5e3thLRddGi8bcRrf1nx624T0BUQuxByIMuiJeLVAakCG9bxYUBmmi/3rEZ0a7N7BqL6n6AJhd6mwdO/HBhTw4+sSOOYzlvJSMpezsxFzJWLIqSHy3i4FC2hPjG6zI3pG3y7sI+u4ySUkj1KQwHEYirYrH5uINHfC4y/UI1sUVIXQxsCQo+qygQ91SdweDGxQbFu/jxJAkUUsXCnNQPbG+Rlpine82dotmC9lp3j5Hij3or7732Jn6z0B8sZOAMgi8NKrLBfzY65lIknv1HXcJa46a0TfijZoDNIE7dMXzy9hLp8KhByHgNgSqcv3glkItllC/SJ3vSQyAoyTmV6T7WsPSaYytHKjxwu7d0xtRVm30fPKtdLWIc1PjxGStoqtv7WYGS4W6Z8opVcjqKoQYckwKE5bttd59wq8ZkPWHG2hVtNQgGecIbUVq/TcG9L+qqsv0/3vzEv6RrigYh2WmZRCD/a/8REc3UZWHvxRsolpxbjOd2vBIK31+PaTS+Q7qdOCnfzigA2ExdVmeG3Ck+teShh0BkeQ0ljwKdVFQ9n3Ekr/Me+LPVszUFn2pp79ylCdYCOVOdbhgz2pu16e4+0PhewJtfT9QzwvIPmUq6BfdANB1ao459v+Y631Zl+tEyN224TQNNh0Oh2fs835C4Lzl4SO/VCZPpnSxFTwfTaQtVJOO6GUuOM33oJWZVJ0jyG629Hi0z3YHfFB83NwtzW5f93HuBycI0qNpgbv1KC++2fDHq+AF3ohidN7imBIoVoMF5aM+A7+B935XLG/Cj/dHahzQjvHC8/4WQq67wOuPDmY9XEAPrOMIXHnFkYpl5MwlBFVd+87L3DF/baRpf/arzochSaSwDSYFSoD+HqMv/PImC+0UUzJ2WtQ3TlYg1d1+S5iab/rCt192ltaz4tbQqaIN4OMG4P7dRY71lZJ4Yw2W0S3L9VBEDqypZUQ6ie1sUnmEebpI9qewawrxKdwtIG2zA5+CNNmsnjpoqcqZ26gh1ZTxrnP76mlvmAJSWXxeUv5DgsxHZOkAao9tPQAgY86KHoCfg9Fxk8sVoP7sm+I1jA95QVKAwH/5o3EUn8H976IycMQlD9Qp7KSz60oIVsLeawOSnC9qIiMyKgxo5i24M+dvvgee3dWUa1B16UPxpr6hBCO6tqSQOHjMJ8zPPMXh2PYHFy6MoQCHIAjNKmxGDRswWJ/GnMJudUMp828cKxkPbT3t/pc+XVbYwDAVJDbdKeVM3AHjILAxT7LYaozdQS9QiIQVkqN47y38b079G19uPPPrRNBQ4Rr5KoyuBC6RmLcA0PCt404jei9mJDvcbXG8XpA+NURJemc2+P/hgcs7aoaeObTHuDqOgD1mo3rulcmcHE5s+f0DRhdA7GNEcrPO/r5iFxKcAz03zkq/rS3YzKBN6JIrhK5fyvgw9l4blzlVbdxp+K1BbLdMA4o7qilwNAjolnYViFW4vRWOynSo4p73sc5kLG2pbbiPoWxsSJfpGuZddxaIcHQ/iiREJ5WLvArVTFhAoUXWjMz4zm1p9JZuHYMVNj5z/tyNtajKjf6wR/34Ag3u0QbtjxIx8ReLpFiEDFfncNVMU</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=/js/crypto-js.js&gt;&lt;/script&gt;
&lt;script&gt;
function doDecrypt (pwd, onError) {
	console.log(&#39;in doDecrypt&#39;);
	const txt = document.getE
      
    
    </summary>
    
    
      <category term="C语言" scheme="https://wangzipai.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>PWM输出</title>
    <link href="https://wangzipai.github.io/posts/7876/"/>
    <id>https://wangzipai.github.io/posts/7876/</id>
    <published>2019-04-15T12:45:42.000Z</published>
    <updated>2019-04-17T13:43:19.264Z</updated>
    
    <content type="html"><![CDATA[<p>PWM在电力电子技术中占据着重要的地位，被广泛的应用在逆变电路中。</p><a id="more"></a><p>STM32中PWM工作过程</p><p><img src="//wangzipai.github.io/posts/7876/PWM工作过程.png" alt></p><p>在调用PWM时，首先要使能TIM3外设的时钟，并对TIM3通道相应的GPIO引脚做相应的配置。配置好GPIO后，还要时基初始化、输出模式初始化和装载捕获/比较寄存器的数值。</p><p>时基配置：</p><p>TIM_Period:定时周期，实质是存储到重载寄存器TIMx_ARR大的数值。</p><p>TIM_Prescaler:对定时器时钟TIMxCLK的预分频值，分频后作为脉冲计数器的驱动时钟。</p><p>TIM_ClockDivision:时钟分频因子。怎么又出现一个配置时钟分频的呢？要注意这个TIM_ClockDivision与TIM_Prescaler不同。TIM_Prescaler预分频是对TIMxCLK进行分频，分频后的时钟被输出到脉冲计数器中，而TIM_ClockDivision虽然也是对TIMxCLK进行分频，但被输出到定时器的ETPR数字滤波器部分，会影响滤波器的采样频率。ETPR数字滤波器的作用是对外部时钟TIMxETR进行滤波。本实验中无意义。</p><p>TIM_CounterMode:本成员配置的为脉冲计数器的计数模式。（向上、向下、中央对齐）</p><p>输出模式：</p><p>通过定时器的输出模式由TIM_OCInitTypeDef类型结构体的成员配置。</p><p>TIM_OCMode:输出模式配置，主要使用的为PWM1和PWM2模式。</p><p>PWM1模式：向上计数时，当TIMx_CNT&lt;TIMx_CCRn时，通道n输出为有效电平，否则为无效电平；向下计数时，当TIMx_CNT&gt;TIMxCCRn时通道n为无效电平，否则为有效电平。PWM2模式与PWM1模式相反。其中有效电平和无效电平是不固定的，也就是需要（TIM_OCPolarite）配置的。</p><p>TIM_OCPolarite:有效电平极性。</p><p><img src="//wangzipai.github.io/posts/7876/PWM工作过程通道1.png" alt></p><p>CCR1:捕获比较(值)寄存器（x=1,2,3,4):设置比较值。<br>CCMR1: OC1M[2:0]位：<br>              对于PWM方式下，用于设置PWM模式1【110】或者PWM模式2【111】<br>CCER:CC1P位：输入/捕获1输出极性。0：高电平有效，1：低电平有效。<br>CCER:CC1E位：输入/捕获1输出使能。0：关闭，1：打开。</p><p>代码</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void TIM1_PWM_Init(u16 arr,u16 psc)</span><br><span class="line">&#123;  </span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);<span class="comment">// </span></span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);  <span class="comment">//使能GPIO外设时钟使能</span></span><br><span class="line">                                                                     </span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置该引脚为复用输出功能,输出TIM1 CH1的PWM脉冲波形</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; <span class="comment">//TIM_CH1</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, <span class="meta">&amp;GPIO_InitStructure);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值 80K</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为TIMx时钟频率除数的预分频值  不分频</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM向上计数模式</span></span><br><span class="line">TIM_TimeBaseInit(TIM1, <span class="meta">&amp;TIM_TimeBaseStructure); <span class="comment">//根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//选择定时器模式:TIM脉冲宽度调制模式2</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//设置待装入捕获比较寄存器的脉冲值</span></span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性:TIM输出比较极性高</span></span><br><span class="line">TIM_OC1Init(TIM1, <span class="meta">&amp;TIM_OCInitStructure);  <span class="comment">//根据TIM_OCInitStruct中指定的参数初始化外设TIMx</span></span></span><br><span class="line"></span><br><span class="line">  TIM_CtrlPWMOutputs(TIM1,ENABLE);<span class="comment">//MOE 主输出使能</span></span><br><span class="line"></span><br><span class="line">TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  <span class="comment">//CH1预装载使能 </span></span><br><span class="line"></span><br><span class="line">TIM_ARRPreloadConfig(TIM1, ENABLE); <span class="comment">//使能TIMx在ARR上的预装载寄存器，允许或禁止在定时器工作时向ARR的缓冲器中写入新值，以便在更新事件发生时载入覆盖以前的值</span></span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM1, ENABLE);  <span class="comment">//使能TIM1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预装载用于精确波形控制，PWM输出，一般用不到精确波形控制。故开不开都问题不大。<br>在定时器的输出比较模式下，TIMx_CCRx寄存器能够在任何时候通过软件进行更新以控制波形，这个通过软件写入控制波形的值是立即生效呢还是在定时器发生下一次更新事件时被更新的，是由TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_Enable)这条语句决定的！Enable就是下一次更新事件时被更新；Disable是立即生效</p><p>如果是高级定时器，则还需要配置：刹车和死区寄存器（TIMx_BDTR），该寄存器，我们只需要关注最高位：MOE位，要想高级定时器的PWM正常输出，则必须设置MOE位为1，否则不会有输出。注意：通用定时器不需要配置这个。</p><p>主函数</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> int main(void)</span><br><span class="line"> &#123;</span><br><span class="line">u16 led0pwmval=<span class="number">0</span>;    </span><br><span class="line">u8 dir=<span class="number">1</span>;</span><br><span class="line">delay_init();     <span class="comment">//延时函数初始化  </span></span><br><span class="line">LED_Init();  <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">TIM1_PWM_Init(<span class="number">899</span>,<span class="number">0</span>);<span class="comment">//不分频。PWM频率=72000/(899+1)=80Khz </span></span><br><span class="line">   while(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>); </span><br><span class="line">if(dir)led0pwmval++;</span><br><span class="line">else led0pwmval--; </span><br><span class="line"> if(led0pwmval&gt;<span class="number">300</span>)dir=<span class="number">0</span>;</span><br><span class="line">if(led0pwmval==<span class="number">0</span>)dir=<span class="number">1</span>;    </span><br><span class="line">TIM_SetCompare1(TIM1,led0pwmval);   </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然TIM1计数器中的计数值要与76比较，但是这一个周期的时间十分短暂，导致低电平时间过短，达到人眼无法分辨的频率，所以我们觉得LED一直是亮着的，这个时候决定LED变化的只有主函数中最后一段代码中的函数TIM_SetCompare1(TIM1,led0pwmval)中的led0pwmval这个参数决定的占空比，从而影响电压进而影响电流大小，最后导致了LED的亮度的改变。</p><h3 id="关于STM32影子寄存器和预装载寄存器和TIM-ARRPreloadConfig"><a href="#关于STM32影子寄存器和预装载寄存器和TIM-ARRPreloadConfig" class="headerlink" title="关于STM32影子寄存器和预装载寄存器和TIM_ARRPreloadConfig"></a>关于STM32影子寄存器和预装载寄存器和TIM_ARRPreloadConfig</h3><p>1、有影子寄存器的有3个：分频寄存器PSC，自动重装载ARR，自动捕获CCRx,注意，PSC，ARR，CCRx不是影子寄存器，而是它们对应的“预装载寄存器”；</p><p>2、影子寄存器才是真正起作用的寄存器，但是ST没有提供这个寄存器出来，只是提供出与之相对应的预装载寄存器，分别为“PSC,ARR,CCRx”</p><p>3、我们用户能接触到，能修改或读取的都是预装载寄存器，ST只是把它们开放出来(影子寄存器并没有开放给用户)，其实就是ARR寄存器，如：TIM1-&gt;ARR</p><p>4、从预装载寄存器ARR传送到影子寄存器，有两种方式，一种是立刻更新，一种是等触发事件之后更新；这两种方式主要取决于寄存器TIMx-&gt;CR1中的“APRE”位；</p><pre><code>4.1 ， APRE=0，当ARR值被修改时，同时马上更新影子寄存器的值；4.2 ， APRE=1，当ARR值被修改时，必须在下一次事件UEV发生后才能更新影子寄存器的值；</code></pre><p>5、怎么样马上立刻更改影子寄存器的值，而不是下一个事件；方法如下：</p><pre><code>5.1 、将ARPE=0，TIM_ARRPreloadConfig(ch1_Master_Tim, DISABLE );5.2     在ARPE=1，TIM_ARRPreloadConfig(ch1_Master_Tim, ENABLE); 我们更改完预装载寄存器后，立刻设置UEV事件，即更改EGR寄存的UG位，如下：           TIM1-&gt;ARR     =    period-1;     //设置周期           TIM1-&gt;CCR1   =    period&gt;&gt;1;  //设置占空比 50%           TIM_GenerateEventTIM1,TIM_EventSource_Update); //主动发生UEV事件,UG=1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PWM在电力电子技术中占据着重要的地位，被广泛的应用在逆变电路中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>死区时间</title>
    <link href="https://wangzipai.github.io/posts/57562/"/>
    <id>https://wangzipai.github.io/posts/57562/</id>
    <published>2019-04-14T12:42:24.000Z</published>
    <updated>2019-04-14T13:25:36.503Z</updated>
    
    <content type="html"><![CDATA[<p>在H桥、三相桥的PWM驱动电路中，上下两个桥臂的PWM驱动信号是互补的，即上下桥臂轮流导通，但实际上<strong><em>为了防止出现上下两个臂同时导通（会短路），在上下两臂切换时留一段时间，上下臂都施加关闭信号，这个上下臂都断的时间就是死区时间。</em></strong>高级定时器可以配置出输出互补的PWM信号，并且在这个PWM信号中加入死区时间，为电机的控制提供了极大的便利。</p><a id="more"></a><p>关于死区时间，看到有这两种理解，一种是电机电感需要释放能量，一种是功率器件以及电路的延迟需要等待。个人理解他们都是死区时间的考虑因素。</p><ol><li><p>电机的各相输入的控制信号之间设定的互锁时间，留一段时间让储能电感放电，以免造成短路。</p></li><li><p>PWM输出时的Dead Zone(死区)作用是在电平翻转时插入一个时间间隔，更具体的理解是，通常大功率电机、变频器等，末端都是由大功率管、IGBT等元件组成的H桥或3相桥。每个桥的上半桥和下半桥是绝对不能同时导通的，但高速的PWM驱动信号在达到功率元件的控制端时，往往会由于各种各样的原因产生延迟的效果，造成某个半桥元件在应该关断时没有关断，造成功率元件烧毁。</p></li></ol><p><img src="//wangzipai.github.io/posts/57562/死区时间.jpg" alt></p><p><strong><em>在保证不出现短路的情况下，死区时间越短越好。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在H桥、三相桥的PWM驱动电路中，上下两个桥臂的PWM驱动信号是互补的，即上下桥臂轮流导通，但实际上&lt;strong&gt;&lt;em&gt;为了防止出现上下两个臂同时导通（会短路），在上下两臂切换时留一段时间，上下臂都施加关闭信号，这个上下臂都断的时间就是死区时间。&lt;/em&gt;&lt;/strong&gt;高级定时器可以配置出输出互补的PWM信号，并且在这个PWM信号中加入死区时间，为电机的控制提供了极大的便利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32定时器</title>
    <link href="https://wangzipai.github.io/posts/50823/"/>
    <id>https://wangzipai.github.io/posts/50823/</id>
    <published>2019-04-13T13:48:52.000Z</published>
    <updated>2019-04-14T14:04:40.895Z</updated>
    
    <content type="html"><![CDATA[<p>stm32一共有8个16位的定时器，其中TIM6、TIM7是基本定时器，TIM2~5是通用定时器，TIM1和TIM8是高级定时器。这些定时器使STM32具有定时、信号频率测量、信号的PWM测量、PWM输出、三相6步电机控制及编码接口等功能，都是专门为工业控制领域量身定做的。</p><a id="more"></a><p><img src="//wangzipai.github.io/posts/50823/三种STM32定时器区别.png" alt></p><h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><p>基本定时器只具备最基本的定时功能，就是累加的时钟脉冲超过预定时，能触发中断或DMA请求。由于在芯片内部与DAC外设相连，可以通过接触输出驱动DAC，也可以作为其他通用定时器的时钟基准。</p><p>工作时，脉冲计数器TIMx_CNT由时钟触发进行计数，当TIMx_CNT的计数值等于重载寄存器TIMx_ARR中保存的数值N时，产生溢出事件，可触发中断或DMA请求。然后TIMx_CNT的值重新被置为0，重新向上计数。</p><h3 id="通用定时器（Tout（溢出时间）-（ARR-1-PSC-1-Tclk）"><a href="#通用定时器（Tout（溢出时间）-（ARR-1-PSC-1-Tclk）" class="headerlink" title="通用定时器（Tout（溢出时间）=（ARR+1)(PSC+1)/Tclk）"></a>通用定时器（Tout（溢出时间）=（ARR+1)(PSC+1)/Tclk）</h3><p>除了基本的定时时，它主要用于测量脉冲的频率、脉冲宽与PWM脉冲的场合，还具有编码器的接口。</p><p>4 个独立通道（TIMx_CH1~4），这些通道可以用来作为： </p><p>① 输入捕获 </p><p>② 输出比较</p><p>③ PWM 生成(边缘或中间对齐模式) </p><p>④ 单脉冲模式输出 </p><h4 id="捕获-比较寄存器"><a href="#捕获-比较寄存器" class="headerlink" title="捕获/比较寄存器"></a>捕获/比较寄存器</h4><p>通用定时器的基本计时功能与基本定时器的工作方式一样，同样把时钟源经过预分频器输出到脉冲计数器TIMx_CNT累加，溢出时就产生中断或DMA请求。而通用定时器比基本定时器多出的强大功能，就是因为通用定时器多出了一种捕获/比较寄存器TIMx——CCR，它在输入时被用于捕获输入脉冲在电平翻转时脉冲计数器TIMx_CNT的当前计数值，从而实现脉冲的频率测量。在输出时被用来存储一个脉冲数值，把这个数值用于与脉冲计数器TIMx_CNT的当前计数值进行比较，根据比较结果进行不同的电平输出。</p><h4 id="PWM输出过程分析"><a href="#PWM输出过程分析" class="headerlink" title="PWM输出过程分析"></a>PWM输出过程分析</h4><p>通用定时器可以利用GPIO引脚进行脉冲输出，在配置为比较输出、PWM输出功能时，捕获/比较寄存器TIMx_CCR被用作比较功能。</p><p>若配置脉冲计数器TIMx_CNT为向上计数，而重载寄存器TIMx_ARR被配置为N，即TIMx_CNT的当前计数值数值X在TIMxCLK时钟源的驱动下不断累积，当TIMx_CNT的数值X大于N时，会重置TIMx_CNT数值为0并重新计数。而<strong><em>在TIMx_CNT计数的同时，TIMx_CNT的计数值X会与比较寄存器TIMx_CCR预先存储的数值A进行比较。当脉冲计数器的数值X小于计较寄存器的值A时，输出高电平（或低电平）。相反的，X大于A时，输出低电平（或高电平）。</em></strong>如此循环，得到的输出脉冲周期就为重载寄存器存储的数值（N+1）乘以触发脉冲的时钟周期，其脉冲宽度则为比较寄存器TIMx_CCR的值A乘以触发脉冲的时钟周期，即输出PWM的占空比为A/(N+1)。</p><h4 id="PWM输入过程分析"><a href="#PWM输入过程分析" class="headerlink" title="PWM输入过程分析"></a>PWM输入过程分析</h4><p>当定时器被配置为输入功能时，可以用于检测输入到GPIO引脚的信号，此时捕获/比较寄存器TIMx_CCR被用作捕获功能。</p><p><img src="//wangzipai.github.io/posts/50823/PWM输入过程分析.jpg" alt></p><p>要测量的PWM脉冲通过GPIO引脚输入到定时器的脉冲检测通道，其时序为图中TI1。把脉冲计数器配置为向上计数，重载寄存器的N值配置为足够大。在输入脉冲TI1的上升沿到达时，触发IC1和IC2的输入捕获中断，这时把脉冲计数器TIMx_CNT的计数值复位为0，于是TIMx_CNT的计数值X在TIMx_CLK的驱动下从0开始累加直到TI1出现下降沿，触发IC2捕获事件，此时捕获寄存器把脉冲计数器的当前值2存储起来（TIMx_CCR2），而脉冲计数器继续累加，直到TI1出现第二个上升沿，触发IC1的捕获事件，此时TIMx_CNT的当前计数值4被保存到TIMx_CCR1。</p><p>TIMx_CCR1（加1）的值乘以TIMxCLK的周期即为PWM输入脉冲周期，TIMx_CCR2（加1）的值乘以TIMxCLK的周期即为PWM的高电平时间，进而可以计算出PWM脉冲的频率、占空比。</p><h4 id="定时器的时钟源"><a href="#定时器的时钟源" class="headerlink" title="定时器的时钟源"></a>定时器的时钟源</h4><p>从时钟源方面来说，通用定时器比基本定时器多了一个选择，它可以使用外部脉冲作为定时器的时钟源。</p><p>计数器时钟可以由下列时钟源提供：<br>内部时钟(CK_INT)<br>外部时钟模式1：外部输入脚(TIx)<br>外部时钟模式2：外部触发输入(ETR)<br>内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。</p><p>使用外部时钟源时，要使用寄存器进行触发边沿、滤波器带宽的配置。如果选择内部时钟源的话则与基本定时器一样，也为TIMxCLK。但要注意的是，所有定时器使用内部时钟时，定时器的时钟源都被称为TIMxCLK，但TIMxCLK的时钟源并不是完全一样的。</p><p>TIM2~7也就是基本定时器和通用定时器，TIMxCLK的时钟源是APB1预分频器的输出。<strong><em>当APB1的分频系数为1时，则TIM2~7的TIMxCLK直接等于该APB1预分频器的输出，而APB1的分频系数不为1时，TIM2~7的TIMxCLK则为APB1的2倍。</em></strong></p><p>在常见配置中，AHB=72MHz，而APB1预分频器的分频系数被配置为2，则PCLK1刚好达到最大值32MHz，而此时APB1的分频系数不为1，则TIM2~7的时钟TIMxCLK=（AHB/2）*2=72MHz。</p><p>而对于TIM1和TIM8这两个高级定时器，TIMxCLK的时钟来源则是APB2预分频器的输出，同样它也根据分频系数分成2中情况。</p><p>常见的配置中AHB=72MHz，APB2预分频器的分频系数被配置为1，此时PCLK2刚好达到最大值72MHz，而TIMxCLK则直接等于APB2分频器的输出，即TIM1和TIM8的时钟TIMxCLK=AHB=72MHz。</p><p><strong><em>虽然这种配置下最终TIMxCLK的时钟频率相等，但必须清楚他们的时钟来源时有区别的。</em></strong>还要强调的是：TIMxCLK是定时器内部的时钟源，但<strong><em>在时钟输出到脉冲计时器前，还经过了一个预分频器PSC，最终用于驱动脉冲计数器的时钟根据预分频器PSC的配置而定。</em></strong></p><h4 id="定时器中断实现步骤"><a href="#定时器中断实现步骤" class="headerlink" title="定时器中断实现步骤"></a>定时器中断实现步骤</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使能定时器时钟。</span><br><span class="line">      <span class="selector-tag">RCC_APB1PeriphClockCmd</span>();</span><br><span class="line">初始化定时器，配置<span class="selector-tag">ARR</span>,<span class="selector-tag">PSC</span>。</span><br><span class="line">     <span class="selector-tag">TIM_TimeBaseInit</span>();</span><br><span class="line">开启定时器中断，配置<span class="selector-tag">NVIC</span>。</span><br><span class="line">     <span class="selector-tag">void</span> <span class="selector-tag">TIM_ITConfig</span>();</span><br><span class="line">     <span class="selector-tag">NVIC_Init</span>();</span><br><span class="line">使能定时器。</span><br><span class="line">     <span class="selector-tag">TIM_Cmd</span>();</span><br><span class="line">编写中断服务函数。</span><br><span class="line">     <span class="selector-tag">TIMx_IRQHandler</span>();</span><br></pre></td></tr></table></figure><p><img src="//wangzipai.github.io/posts/50823/通用定时器工作过程.png" alt></p><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p>TIM1和TIM8是两个高级定时器，他们具有基本、通用定时器的所有功能，还具有三相6步电机的接口、刹车功能及用于PWM驱动电路的死区时间控制等，使他非常适用于电机控制。相比于通用定时器，高级定时器多出了BRK、DTG两个结构，因而具有<a href="https://wangzipai.github.io/posts/57562/"><strong>死区时间</strong></a>的控制功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;stm32一共有8个16位的定时器，其中TIM6、TIM7是基本定时器，TIM2~5是通用定时器，TIM1和TIM8是高级定时器。这些定时器使STM32具有定时、信号频率测量、信号的PWM测量、PWM输出、三相6步电机控制及编码接口等功能，都是专门为工业控制领域量身定做的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>190413</title>
    <link href="https://wangzipai.github.io/posts/28547/"/>
    <id>https://wangzipai.github.io/posts/28547/</id>
    <published>2019-04-13T07:49:12.000Z</published>
    <updated>2019-04-13T10:33:57.208Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX1+Yh5KTLyOj0fMVtqlnMecskoyKacDMo7Rr8CYekwT3ffBbjPcTxRMFRYRhqMuc2wEXSKz/akH28+btmNCr0O0Roiuee6joiqYA+kZpGFOR+sbYJVqYav3usuoGFv7WhKYymkCdaXJkvqiVj1lPgZ17Rc5pKLoxRBO2u7o+yGtxhmpaY1XmH0hc7aIoWtpNbt+s5iUi5l5CX2DKQxYa7P+d4waDZ7qFaEzZX+qmDJvROfYJjyQ8r6fuzch+t9C8kQrFw+5tJbTRIzdBcPUjB/jtypvE71EVcfPuNjR3DEdZGz9dOfNVdhh9y6urh2AszD5TbYtDZkz3unkh6jN2m7HDJ/PDQtr7Bzf3RxtlFvQjM0hO5HpfIfueNm5A8JQ9LtSKQgh0ClVboS9gqWhnhh1R3D+BRoRFOAT+1xt44Uwit/ug7wKgQQPKXgvG65bfPacoudelJNhOIUQ5hTqmeG+sN1TjMnyv3RW0ta5oRzZjiZUHo/0+v9luCVb0kUzueeSIMFNGZyGHvEsOVUO580ZzRpvjc+1OHROBMTuSMCFEuZrQu+gOj6f4F0RQ7tkZp+J3pSVSi4F0mTgY6jLQuLL4TztTvNyUNhysE1jsAjhgKW9teiW7z0nb3qin+GWnC5oRfxp40Xdo59o44jzONtoT64hWKDDHXC0Y6nw1MQ9j4THHsCFGDHz/aViU6Ba+QE9nJ/sguiuW16aHCIn7J53XQqJu6StxKg/C3se4R4Xe7U9HpXBEzJeBvrJQGTU+DXrloANd5uddBGSehO55YzLwUTQiHjUV+I1488xI6eQHgT93TiAtiWTQQc2ONB7XNXCg64Z+334t5Rm69ismUOwVj0+boFZMR63hB9Hp+sNBDUkz5U0p2LrbLlgy9zT92sfYzdXKlndqre6okkaxkqB9lsIoFKMVE8x+ozHaty+d0djJBVFuFGV41biY1BI7zi1CRv5VnEksvkRCLM/bSJ0jwDG9TbPt5SA+TcwrYduo2rdlRuyjN5vdyCHRVGdvj9n9DxSfF7AW4tDfGrnq4ix2nRn1DdoBeG0um63augw7qq/UOHwsxpgjDUH4SQPxldd6WM0cjIm9aKjo4l+6q8He3TYlk0Tdqs8vJHnBNQ5ordfW9OLfy4eAlxv2H54SuFlTWUO6wPMIA+9Nh+Fc3DQxVKVTK+ZuD6VhfGijaCpUIDcKW5d6jf0EiNAuRx3sUoZZzPQaP9l51KILgMF7xAqcNazVKRHiZ9oPiM1B2buZ6QwnTsJm829bQ06iRH6Nf5ECMRsCU6t2w0THdk1SRdreZnAe2JF9+9vZnptN3oaRrZgNmrfnT1XnOdllVBd7zfjghQ1U40GA187B3DN8RoZfl2D983lHnPdhxiuhs2p4Di5I0D/8nGZeFQk2BcWDX8crSXAd6YdofKSomEWG/Tm6DKfOyqDA1e++EP+Do8ItI4ZY4ihJhEsNWLlXj7famhb2d02UMJAV4hNzY2ESDfDVO4cb2rZwvYN45M3KBaPjzlYp+6XoRCb7gnnK08PwMUvRBfh3i0BMiUbDPaCgf7Tn9HtJ/xBGBEo=</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=/js/crypto-js.js&gt;&lt;/script&gt;
&lt;script&gt;
function doDecrypt (pwd, onError) {
	console.log(&#39;in doDecrypt&#39;);
	const txt = document.getE
      
    
    </summary>
    
    
      <category term="hide" scheme="https://wangzipai.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>看门狗</title>
    <link href="https://wangzipai.github.io/posts/59401/"/>
    <id>https://wangzipai.github.io/posts/59401/</id>
    <published>2019-04-11T15:52:24.000Z</published>
    <updated>2019-04-13T08:48:12.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要看门狗"><a href="#为什么要看门狗" class="headerlink" title="为什么要看门狗"></a>为什么要看门狗</h3><p>在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统的陷入停滞状态，发生不可预料的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的模块或者芯片，俗称“看门狗”(watchdog) 。</p><a id="more"></a><h3 id="看门狗解决的问题是什么"><a href="#看门狗解决的问题是什么" class="headerlink" title="看门狗解决的问题是什么"></a>看门狗解决的问题是什么</h3><p>在启动正常运行的时候，系统不能复位。在系统跑飞（程序异常执行）的情况，系统复位，程序重新执行。</p><h3 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h3><p>独立看门狗（IWDG)由专用的低速时钟（LSI)驱动，<strong><em>即使主时钟发生故障它仍有效。</em></strong>独立看门狗适合应用于需要看门狗作<strong><em>为一个在主程序之外能够完全独立工作</em></strong>，并且对时间精度要求低的场合。</p><h4 id="独立看门狗功能描述"><a href="#独立看门狗功能描述" class="headerlink" title="独立看门狗功能描述"></a>独立看门狗功能描述</h4><p>在键值寄存器（IWDG_KR)中写入0xCCCC，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数到尾值0x000时会产生一个复位信号（IWDG_RESET)。<br>无论何时，只要在键值寄存器IWDG_KR中写入0xAAAA（通常说的喂狗）, 自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。<br>如果程序异常，就无法正常喂狗，从而系统复位。</p><p><strong><em>溢出时间计算：Tout=((4×2^prer) ×rlr) /40 （M3)</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_WriteAccessCmd</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_WriteAccess)</span></span>;<span class="comment">//取消写保护：0x5555使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetPrescaler</span><span class="params">(<span class="keyword">uint8_t</span> IWDG_Prescaler)</span></span>;<span class="comment">//设置预分频系数：写PR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetReload</span><span class="params">(<span class="keyword">uint16_t</span> Reload)</span></span>;<span class="comment">//设置重装载值：写RLR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_ReloadCounter</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//喂狗：写0xAAAA到KR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//使能看门狗：写0xCCCC到KR</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">IWDG_GetFlagStatus</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_FLAG)</span></span>;<span class="comment">//状态：重装载/预分频 更新</span></span><br></pre></td></tr></table></figure><h3 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h3><p>窗口看门狗由从APB1时钟分频后得到时钟驱动。通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</p><p>之所以称为窗口就是因为其喂狗时间是一个有上下限的范围内(窗口），你可以通过设定相关寄存器，设定其上限时间（下限固定）。喂狗的时间不能过早也不能过晚。</p><p>而独立看门狗限制喂狗时间在0-x内，x由相关寄存器决定。喂狗的时间不能过晚。</p><p><img src="//wangzipai.github.io/posts/59401/图片1.png" alt></p><p>STM32F的窗口看门狗中有一个7位的递减计数器T[6:0]，它会在出现下述2种情况之一时产生看门狗复位：<br>1 当喂狗的时候如果计数器的值大于某一设定数值W[6:0]时，此设定数值在WWDG_CFR寄存器定义。当计数器的数值从0x40减到0x3F时【T6位跳变到0】 。<br>2 如果启动了看门狗并且允许中断，当递减计数器等于0x40时产生早期唤醒中断（EWI),它可以用于喂狗以避免WWDG复位。</p><p><strong><em>超时时间：Twwdg = ( 4096 </em> 2 ^ WDGTB <em> ( T [5:0] + 1)) / Fpclk1</em></strong></p><p>WDGTB:WWDG的预分频系数</p><p>Fpclk1：APB1的时钟频率</p><p>T [5:0] ： 窗口看门狗计数器底6位</p><h4 id="为什么要窗口看门狗？"><a href="#为什么要窗口看门狗？" class="headerlink" title="为什么要窗口看门狗？"></a>为什么要窗口看门狗？</h4><p>对于一般的看门狗，程序可以在它产生复位前的任意时刻刷新看门狗，但这有一个隐患，有可能程序跑乱了又跑回到正常的地方，或跑乱的程序正好执行了刷新看门狗操作，这样的情况下一般的看门狗就检测不出来了；<br>如果使用窗口看门狗，程序员可以根据程序正常执行的时间设置刷新看门狗的一个时间窗口，保证不会提前刷新看门狗也不会滞后刷新看门狗，这样可以检测出程序没有按照正常的路径运行非正常地跳过了某些程序段的情况。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能看门狗时钟：</span></span><br><span class="line">    <span class="selector-tag">RCC_APB1PeriphClockCmd</span>();</span><br><span class="line"><span class="comment">//设置分频系数：</span></span><br><span class="line">    <span class="selector-tag">WWDG_SetPrescaler</span>();</span><br><span class="line"><span class="comment">//设置上窗口值：</span></span><br><span class="line">    <span class="selector-tag">WWDG_SetWindowValue</span>();</span><br><span class="line"><span class="comment">//开启提前唤醒中断并分组(可选)：</span></span><br><span class="line">    <span class="selector-tag">WWDG_EnableIT</span>();   </span><br><span class="line">    <span class="selector-tag">NVIC_Init</span>();</span><br><span class="line"><span class="comment">//使能看门狗：</span></span><br><span class="line">    <span class="selector-tag">WWDG_Enable</span>();</span><br><span class="line"><span class="comment">//喂狗:</span></span><br><span class="line">   <span class="selector-tag">WWDG_SetCounter</span>();</span><br><span class="line"><span class="comment">//编写中断服务函数</span></span><br><span class="line">  <span class="selector-tag">WWDG_IRQHandler</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要看门狗&quot;&gt;&lt;a href=&quot;#为什么要看门狗&quot; class=&quot;headerlink&quot; title=&quot;为什么要看门狗&quot;&gt;&lt;/a&gt;为什么要看门狗&lt;/h3&gt;&lt;p&gt;在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统的陷入停滞状态，发生不可预料的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的模块或者芯片，俗称“看门狗”(watchdog) 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
      <category term="嵌入式" scheme="https://wangzipai.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>stm32的printf函数</title>
    <link href="https://wangzipai.github.io/posts/11595/"/>
    <id>https://wangzipai.github.io/posts/11595/</id>
    <published>2019-04-09T13:58:54.000Z</published>
    <updated>2019-04-09T14:58:32.783Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的USART实验中调用了printf函数来打印发送的信息。printf()函数用法和在纯C语言编程中看起来好像没有区别，但实际上在调用printf()函数的时候，我们需要把printf()重新定向到串口中。重定向是指用户可以自己重新写C的库函数，当连接器检查到用户编写了与C库函数相同的名字的函数时，优先采用用户编写的函数，这样用户就可以实现对库的修改了。</p><a id="more"></a><p>为了实现重定向printf()函数，我们需要重写fputc()这个C标准库函数，因为<strong><em>printf()在C标准函数中实际是一个宏，最终是调用了fputc()这个函数。</em></strong></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fputc(<span class="keyword">int</span> ch, FILE *f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">USART1-&gt;DR = (u8) ch;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重定向时，我们把fputc()的形参ch，作为串口将要发送的数据，也就是说，当使用printf()时，他先调用这个fputc()函数，然后将ch的值赋值给USART1的数据寄存器，触发串口向PC发送一个相应的数据。（当我们需要发送数据时，内核或DMA外设把数据从内存写入发送数据寄存器TDR后，发送控制寄存器将适时的自动把数据从TDR加载到发送移位寄存器，然后通过串口线Tx，把数据一位一位的发送出去，当数据从TDR转移到移位寄存器时，会产生发送寄存器TDR已空事件TXE，当数据从移位寄存器全部发送出去时，会产生数据发送完成事件TC，这些事件可以在状态寄存器中查询到。）</p><p><strong><em>若使用C标准输出库函数，需要在main.c文件中把stdio.h这个头文件包含进来，还要在编译器中设置一个选项UseMicroLIB (使用微库)</em></strong>，这个微库是Keil MDK为嵌入式应用量身定做的C库，我们要先具有库才能重定向，勾选使用后，就可以使用printf()这个函数了。</p><p>除了重定向的方法，我们还可以自己编写格式输入输出函数，功能和重定向之后的printf()函数类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的USART实验中调用了printf函数来打印发送的信息。printf()函数用法和在纯C语言编程中看起来好像没有区别，但实际上在调用printf()函数的时候，我们需要把printf()重新定向到串口中。重定向是指用户可以自己重新写C的库函数，当连接器检查到用户编写了与C库函数相同的名字的函数时，优先采用用户编写的函数，这样用户就可以实现对库的修改了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>c与指针读书笔记（1）</title>
    <link href="https://wangzipai.github.io/posts/54171/"/>
    <id>https://wangzipai.github.io/posts/54171/</id>
    <published>2019-04-08T15:52:33.000Z</published>
    <updated>2019-04-09T14:59:02.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在C语言中有两种注释方式：</p><p>一种是以<code>/*</code>开始、以<code>*/</code>结束的块注释（block comment），</p><p>另一种是以<code>//</code>开始、以换行符结束的单行注释（line comment）。</p><p>预处理器仅通过检查注释的结束符来检测注释中的字符，因此，不能嵌套块注释。在有些语言中，注释有时用于把一段代码“注释掉”，也就是使这段代码在程序中不起作用，<strong><em>但并不是将其真正从源文件中删除</em></strong>。在C语言中，如果用<code>/*</code>和<code>*/</code>来注释掉原先就有注释的代码，会出现问题。要从逻辑上删除一段C代码，更好的办法是使用#if指令。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">statements</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在#if和#endif之间的程序段就可以有效的从程序中去除了，这是一种更为安全的方法。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_COLS 20   <span class="comment">//所能处理的最大列号 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_INPUT 1000<span class="comment">//每个输入行的最大长度</span></span></span><br></pre></td></tr></table></figure><p>这5行就是预处理指令，因为他们是由预处理器解释的。<strong><em>预处理器读入源码，根据预处理指令对其修改，然后把修改过的源码交给编译器。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h3&gt;&lt;p&gt;在C语言中有两种注释方式：&lt;/p&gt;
&lt;p&gt;一种是以&lt;code&gt;/*&lt;/code&gt;开始、以&lt;code&gt;*/&lt;/code&gt;结束的块注释（block comment），&lt;/p&gt;
&lt;p&gt;另一种是以&lt;code&gt;//&lt;/code&gt;开始、以换行符结束的单行注释（line comment）。&lt;/p&gt;
&lt;p&gt;预处理器仅通过检查注释的结束符来检测注释中的字符，因此，不能嵌套块注释。在有些语言中，注释有时用于把一段代码“注释掉”，也就是使这段代码在程序中不起作用，&lt;strong&gt;&lt;em&gt;但并不是将其真正从源文件中删除&lt;/em&gt;&lt;/strong&gt;。在C语言中，如果用&lt;code&gt;/*&lt;/code&gt;和&lt;code&gt;*/&lt;/code&gt;来注释掉原先就有注释的代码，会出现问题。要从逻辑上删除一段C代码，更好的办法是使用#if指令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c语言" scheme="https://wangzipai.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="c与指针" scheme="https://wangzipai.github.io/tags/c%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>串行通信原理梳理</title>
    <link href="https://wangzipai.github.io/posts/24857/"/>
    <id>https://wangzipai.github.io/posts/24857/</id>
    <published>2019-04-02T13:26:15.000Z</published>
    <updated>2019-04-09T14:46:50.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然之前在一些课程中已经学习过关于串行通信原理的知识，但一直没有总结，很多知识也都忘记了。今天就重新梳理一下。</p><a id="more"></a><p>妈蛋，发送端的跳线帽坏了，害我白浪费好长的时间排错。</p><p>清明放假（荒废）3天。。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="处理器与外部设备通信的两种方式"><a href="#处理器与外部设备通信的两种方式" class="headerlink" title="处理器与外部设备通信的两种方式"></a>处理器与外部设备通信的两种方式</h3><h4 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h4><p>传输原理：数据各个位同时传输。<br>优点：速度快<br>缺点：占用引脚资源多</p><h4 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h4><p>传输原理：数据按位顺序传输。<br>优点：占用引脚资源少<br>缺点：速度相对较慢</p><h5 id="按照数据传送方向，分为"><a href="#按照数据传送方向，分为" class="headerlink" title="按照数据传送方向，分为"></a>按照数据传送方向，分为</h5><p>单工：数据传输只支持数据在一个方向上传输<br>半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；<br>全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 </p><h5 id="串行通信的通信方式"><a href="#串行通信的通信方式" class="headerlink" title="串行通信的通信方式"></a>串行通信的通信方式</h5><p>同步通信：带时钟同步信号传输。<br>    -SPI（全双工），IIC（半双工）通信接口<br>异步通信：不带时钟同步信号。<br>    -UART(通用异步收发器),单总线（USART:通用同步异步收发器，USART可用作UART使用）</p><h5 id="UART异步通信方式特点"><a href="#UART异步通信方式特点" class="headerlink" title="UART异步通信方式特点"></a>UART异步通信方式特点</h5><p>全双工异步通信。<br>分数波特率发生器系统，提供精确的波特率。-发送和接受共用的可编程波特率，最高可达4.5Mbits/s<br>可编程的数据字长度（8位或者9位）；<br>可配置的停止位（支持1或者2位停止位）；<br>可配置的使用DMA多缓冲器通信。<br>单独的发送器和接收器使能位。<br>检测标志：① 接受缓冲器  ②发送缓冲器空 ③传输结束标志<br>多个带标志的中断源。触发中断。<br>其他：校验控制，四个错误检测标志。</p><h5 id="STM32串口异步通信需要定义的参数："><a href="#STM32串口异步通信需要定义的参数：" class="headerlink" title="STM32串口异步通信需要定义的参数："></a>STM32串口异步通信需要定义的参数：</h5><p> 起始位<br> 数据位（8位或者9位）<br> 奇偶校验位（第9位）<br> 停止位（1,15,2位）<br> 波特率设置</p><p>通过对时钟的控制可以改变波特率。在配置波特率时，向USART_BRR波特率寄存器写入参数，修改串口时钟的分频值USARTDIV。USART_BRR包括2部分（整数部分和小数部分）。</p><p><strong><em>对于USART1，由于挂载在APB2总线上，所以他的时钟源为fPCLK2;而USART2，USART3挂载在APB1上，时钟源为fPCLK1。</em></strong></p><h3 id="直通线与交叉线"><a href="#直通线与交叉线" class="headerlink" title="直通线与交叉线"></a>直通线与交叉线</h3><p>串口线主要分为2种：直通线与交叉线。假如PC与板子之间要实现全双工串口通信，必然是PC的Tx针脚要连接到板子的Rx脚，PC的Rx针脚要连接到板子的Tx脚。由于板子和电脑的串口接法是相同的，就要使用交叉线来连接了。设计板子时尽量采用与PC相同的标准串口接法。</p><h2 id="常用的串口相关寄存器"><a href="#常用的串口相关寄存器" class="headerlink" title="常用的串口相关寄存器"></a>常用的串口相关寄存器</h2><p>USART_SR状态寄存器<br>USART_DR数据寄存器<br>USART_BRR波特率寄存器 </p><p>当我们需要发送数据时，内核或DMA外设把数据从内存写入发送数据寄存器TDR后，发送控制寄存器将适时的自动把数据从TDR加载到发送移位寄存器，然后通过串口线Tx，把数据一位一位的发送出去，当数据从TDR转移到移位寄存器时，会产生发送寄存器TDR已空事件TXE，当数据从移位寄存器全部发送出去时，会产生数据发送完成事件TC，这些事件可以在状态寄存器中查询到。</p><p><img src="//wangzipai.github.io/posts/24857/图片1.png" alt></p><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="串口操作相关库函数"><a href="#串口操作相关库函数" class="headerlink" title="串口操作相关库函数"></a>串口操作相关库函数</h3><p>void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能<br>void USART_Cmd();//使能串口<br>void USART_ITConfig();//使能相关中断</p><p>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</p><p>FlagStatus USART_GetFlagStatus();//获取状态标志位<br>void USART_ClearFlag();//清除状态标志位<br>ITStatus USART_GetITStatus();//获取中断状态标志位<br>void USART_ClearITPendingBit();//清除中断状态标志位</p><h3 id="串口配置一般步骤"><a href="#串口配置一般步骤" class="headerlink" title="串口配置一般步骤"></a>串口配置一般步骤</h3><h4 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h4><p>PA9,PA10（串口1）连接到了USB串口电路。</p><h4 id="串口配置的一般步骤"><a href="#串口配置的一般步骤" class="headerlink" title="串口配置的一般步骤"></a>串口配置的一般步骤</h4><p>1串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();<br>2串口复位:USART_DeInit(); 这一步不是必须的<br>3GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP<br>4串口参数初始化：USART_Init();</p><p>​    <strong><em>硬件流：功能表现为：当外设硬件处于准备好的状态时，硬件启动自动控制，不需要软件再进行干预。</em></strong></p><p>5开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）<br>      NVIC_Init();<br>      USART_ITConfig();<br>6使能串口:USART_Cmd(); （<strong><em>使用外设时，不仅要使用其时钟，还要调用此函数使能外设</em></strong>）<br>7编写中断处理函数：USARTx_IRQHandler();<br>8串口数据收发：<br>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据<br>9串口传输状态获取：<br>FlagStatus USART_GetFlagStatus(USART_TypeDef<em> USARTx, uint16_t USART_FLAG);<br>void USART_ClearITPendingBit(USART_TypeDef</em> USARTx, uint16_t USART_IT);</p><hr><h2 id="USART代码分析"><a href="#USART代码分析" class="headerlink" title="USART代码分析"></a>USART代码分析</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USART_REC_LEN  200  <span class="comment">//定义最大接收字节数 200</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN_USART1_RX 1<span class="comment">//使能（1）/禁止（0）串口1接收</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> u8  USART_RX_BUF[USART_REC_LEN]; <span class="comment">//接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 </span></span><br><span class="line"><span class="keyword">extern</span> u16 USART_RX_STA;         <span class="comment">//接收状态标记</span></span><br><span class="line"><span class="comment">//如果想串口中断接收，请不要注释以下宏定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">(u32 bound)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="串口1中断服务程序"><a href="#串口1中断服务程序" class="headerlink" title="串口1中断服务程序"></a>串口1中断服务程序</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">USART1_IRQHandler</span>(void)                <span class="comment">//串口1中断服务程序</span></span><br><span class="line">&#123;</span><br><span class="line">u8 Res;</span><br><span class="line"><span class="meta">#if SYSTEM_SUPPORT_OS <span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line"><span class="built_in">OSIntEnter</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">USART_GetITStatus</span>(USART1, USART_IT_RXNE) != RESET)  <span class="comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span></span><br><span class="line">&#123;</span><br><span class="line">Res =<span class="built_in">USART_ReceiveData</span>(USART1);<span class="comment">//(USART1-&gt;DR); //读取接收到的数据</span></span><br><span class="line"><span class="keyword">if</span>((USART_RX_STA&amp;<span class="number">0x8000</span>)==<span class="number">0</span>)<span class="comment">//接收未完成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&amp;<span class="number">0x4000</span>)<span class="comment">//接收到了0x0d</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Res!=<span class="number">0x0a</span>)<span class="built_in">USART_RX_STA</span>=<span class="number">0</span>;<span class="comment">//接收错误,重新开始</span></span><br><span class="line"><span class="keyword">else</span> USART_RX_STA|=<span class="number">0x8000</span>;<span class="comment">//接收完成了 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//还没收到0X0D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Res==<span class="number">0x0d</span>)<span class="built_in">USART_RX_STA</span>|=<span class="number">0x4000</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">USART_RX_BUF[USART_RX_STA&amp;<span class="number">0X3FFF</span>]=Res ;<span class="comment">//接收缓冲</span></span><br><span class="line">USART_RX_STA++;</span><br><span class="line"><span class="keyword">if</span>(USART_RX_STA&gt;(USART_REC_LEN<span class="number">-1</span>))<span class="built_in">USART_RX_STA</span>=<span class="number">0</span>;<span class="comment">//接收数据错误,重新开始接收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#if SYSTEM_SUPPORT_OS <span class="comment">//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.</span></span></span><br><span class="line"><span class="built_in">OSIntExit</span>();   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>USART_RX_STA接收状态标记，bit15 接收完成标志，bit14 接收到0x0d，bit13~0，接收到的有效字节数目。</p><p>程序要求，发送的字符是以回车换行结束（0x0D,0x0A)。</p><p> 当接收到从电脑发过来的数据，把接收到的数据保存在 USART_RX_BUF 中，同时在接收状态寄存器（USART_RX_STA）中计数接收到的有效数据个数，当收到回车（回车的表示由 2 个字节组成：0X0D 和 0X0A）的第一个字节 0X0D 时，计数器将不再增加，等待0X0A 的到来，而如果 0X0A 没有来到，则认为这次接收失败，重新开始下一次接收。如果顺利接收到 0X0A，则标记 USART_RX_STA 的第 15 位，这样完成一次接收，并等待该位被其他程序清除，从而开始下一次的接收，而如果迟迟没有收到 0X0D，那么在接收数据超过 USART_REC_LEN 的时候，则会丢弃前面的数据，重新接收。</p><p> 计算机向串口发送一串字符，一般不止一个，例如发送”abcdefg回车“。那么<strong><em>串口中断函数会执行9次</em></strong>，回车要执行两次串口中断。当串口中断函数第一次执行时，USART1-&gt;DR里面装的是字符a，下面以串口第一次执行来分析这个串口中断函数。if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)这是判断读数据寄存器是否空，因为接受到了a，所以不是空的，这个判断成立。Res =USART_ReceiveData(USART1);//(USART1-&gt;DR); 既然接受到了字符a，那么就要把他读取出来。 if((USART_RX_STA&amp;0x8000)==0) 因为现在接受的是第一个字符，所以接收肯定没有完成，USART_RX_STA还是它的初始化值，于是第15位还是0，这个判断语句成立。于是要执行下面这句话  if(USART_RX_STA&amp;0x4000)   USART_RX_STA的第14位仍然是0，所以这个判断不成立，所以会执行下面这句话。if(Res==0x0d) 当然这个判断也不成立，所以要执行下面这句话。USART_RX_BUF[USART_RX_STA&amp;0X3FFF]=Res ;计算出接收的是第几个字符，然后装到缓存里面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;虽然之前在一些课程中已经学习过关于串行通信原理的知识，但一直没有总结，很多知识也都忘记了。今天就重新梳理一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>EXTI外部中断</title>
    <link href="https://wangzipai.github.io/posts/13433/"/>
    <id>https://wangzipai.github.io/posts/13433/</id>
    <published>2019-03-31T06:31:35.000Z</published>
    <updated>2019-04-07T16:17:14.291Z</updated>
    
    <content type="html"><![CDATA[<p>EXTI(External Intertupt)就是指外部中断，通过GPIO检测输入脉冲，引起中断事件，打断原来的代码执行流程，进入中断服务函数中进行处理，处理完后再回到中断之前的函数执行。CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。STM32F103系列上面，又只有60个可屏蔽中断。</p><a id="more"></a><p>stm32的所有GPIO都引入到EXTI外部中断线上，使得所有的GPIO都能作为外部中断的输入源。<br>STM32的中断控制器支持19个外部中断/事件请求：<br>线0~15：对应外部IO口的输入中断。<br>线16：连接到PVD输出。<br>线17：连接到RTC闹钟事件。<br>线18：连接到USB唤醒事件。<br>每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位。<strong><em>PAx~PGx端口的中断事件都连接到EXTIx</em></strong>，即同一时刻EXTIx只能响应一个端口的事件触发，不能同一时间响应所有的GPIO端口的事件，但可以分时复用。</p><p><img src="//wangzipai.github.io/posts/13433/图片1.png" alt></p><h3 id="AFIO"><a href="#AFIO" class="headerlink" title="AFIO"></a>AFIO</h3><p>AFIO指GPIO端口的复用功能，当把GPIO用作EXTI外部中断或使用重映射功能时，必须开启AFIO时钟，而再使用默认复用功能的时候，不必开启AFIO时钟。</p><h3 id="EXTI初始化配置"><a href="#EXTI初始化配置" class="headerlink" title="EXTI初始化配置"></a>EXTI初始化配置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line;   <span class="comment">//指定要配置的中断线           </span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   <span class="comment">//模式：事件 OR中断</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;<span class="comment">//触发方式：上升沿/下降沿/双沿触发</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;  <span class="comment">//使能 OR失能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXTI_InitStructure.EXTI_Line=EXTI_Line2;</span> </span><br><span class="line"><span class="keyword">EXTI_InitStructure.EXTI_Mode </span>= <span class="keyword">EXTI_Mode_Interrupt;</span></span><br><span class="line"><span class="keyword">EXTI_InitStructure.EXTI_Trigger </span>= <span class="keyword">EXTI_Trigger_Falling;</span></span><br><span class="line"><span class="keyword">EXTI_InitStructure.EXTI_LineCmd </span>= ENABLE<span class="comment">;</span></span><br><span class="line"><span class="keyword">EXTI_Init(&amp;EXTI_InitStructure);</span></span><br></pre></td></tr></table></figure><h3 id="编写中断服务函数"><a href="#编写中断服务函数" class="headerlink" title="编写中断服务函数"></a>编写中断服务函数</h3><p>stm32f10x_it.c文件是专门用来存放中断服务函数的。文件中默认只有几个关于系统异常的中断服务函数，且都是空函数，在需要的时候自行编写。（不可以自定义函数名，中断服务函数名必须与启动文件startup_stm32f10x_hd.s中的中断向量表定义一致）</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DCD     <span class="keyword">EXTI0_IRQHandler </span>          <span class="comment">; EXTI Line 0</span></span><br><span class="line">DCD     <span class="keyword">EXTI1_IRQHandler </span>          <span class="comment">; EXTI Line 1</span></span><br><span class="line">DCD     <span class="keyword">EXTI2_IRQHandler </span>          <span class="comment">; EXTI Line 2</span></span><br><span class="line">DCD     <span class="keyword">EXTI3_IRQHandler </span>          <span class="comment">; EXTI Line 3</span></span><br><span class="line">DCD     <span class="keyword">EXTI4_IRQHandler </span>          <span class="comment">; EXTI Line 4</span></span><br><span class="line">DCD     DMA1_Channel1_IRQHandler   <span class="comment">; DMA1 Channel 1</span></span><br><span class="line">DCD     DMA1_Channel2_IRQHandler   <span class="comment">; DMA1 Channel 2</span></span><br><span class="line">DCD     DMA1_Channel3_IRQHandler   <span class="comment">; DMA1 Channel 3</span></span><br><span class="line">DCD     DMA1_Channel4_IRQHandler   <span class="comment">; DMA1 Channel 4</span></span><br><span class="line">DCD     DMA1_Channel5_IRQHandler   <span class="comment">; DMA1 Channel 5</span></span><br><span class="line">DCD     DMA1_Channel6_IRQHandler   <span class="comment">; DMA1 Channel 6</span></span><br><span class="line">DCD     DMA1_Channel7_IRQHandler   <span class="comment">; DMA1 Channel 7</span></span><br><span class="line">DCD     ADC1_2_IRQHandler          <span class="comment">; ADC1 &amp; ADC2</span></span><br><span class="line">DCD     USB_HP_CAN1_TX_IRQHandler  <span class="comment">; USB High Priority or CAN1 TX</span></span><br><span class="line">DCD     USB_LP_CAN1_RX0_IRQHandler <span class="comment">; USB Low  Priority or CAN1 RX0</span></span><br><span class="line">DCD     CAN1_RX1_IRQHandler        <span class="comment">; CAN1 RX1</span></span><br><span class="line">DCD     CAN1_SCE_IRQHandler        <span class="comment">; CAN1 SCE</span></span><br><span class="line">DCD     <span class="keyword">EXTI9_5_IRQHandler </span>        <span class="comment">; EXTI Line 9..5</span></span><br><span class="line">DCD     TIM1_BRK_IRQHandler        <span class="comment">; TIM1 Break</span></span><br><span class="line">DCD     TIM1_UP_IRQHandler         <span class="comment">; TIM1 Update</span></span><br><span class="line">DCD     TIM1_TRG_COM_IRQHandler    <span class="comment">; TIM1 Trigger and Commutation</span></span><br><span class="line">DCD     TIM1_CC_IRQHandler         <span class="comment">; TIM1 Capture Compare</span></span><br><span class="line">DCD     TIM2_IRQHandler            <span class="comment">; TIM2</span></span><br><span class="line">DCD     TIM3_IRQHandler            <span class="comment">; TIM3</span></span><br><span class="line">DCD     TIM4_IRQHandler            <span class="comment">; TIM4</span></span><br><span class="line">DCD     I2C1_EV_IRQHandler         <span class="comment">; I2C1 Event</span></span><br><span class="line">DCD     I2C1_ER_IRQHandler         <span class="comment">; I2C1 Error</span></span><br><span class="line">DCD     I2C2_EV_IRQHandler         <span class="comment">; I2C2 Event</span></span><br><span class="line">DCD     I2C2_ER_IRQHandler         <span class="comment">; I2C2 Error</span></span><br><span class="line">DCD     SPI1_IRQHandler            <span class="comment">; SPI1</span></span><br><span class="line">DCD     SPI2_IRQHandler            <span class="comment">; SPI2</span></span><br><span class="line">DCD     USART1_IRQHandler          <span class="comment">; USART1</span></span><br><span class="line">DCD     USART2_IRQHandler          <span class="comment">; USART2</span></span><br><span class="line">DCD     USART3_IRQHandler          <span class="comment">; USART3</span></span><br><span class="line">DCD     <span class="keyword">EXTI15_10_IRQHandler </span>      <span class="comment">; EXTI Line 15..10</span></span><br></pre></td></tr></table></figure><p><strong><em>中断线在5之后就不能像0~4那样只有单独一个函数名，必须写成<code>EXTI9_5_IRQHandler</code> 和<code>EXTI15_10_IRQHandler</code>。</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI9_5_IRQHandler</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LED1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1 = !LED1；</span><br><span class="line">        EXTI_ClearITPendingBit(EXTI_Line5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EXTI(External Intertupt)就是指外部中断，通过GPIO检测输入脉冲，引起中断事件，打断原来的代码执行流程，进入中断服务函数中进行处理，处理完后再回到中断之前的函数执行。CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。STM32F103系列上面，又只有60个可屏蔽中断。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>NVIC中断优先级管理</title>
    <link href="https://wangzipai.github.io/posts/32250/"/>
    <id>https://wangzipai.github.io/posts/32250/</id>
    <published>2019-03-31T05:44:11.000Z</published>
    <updated>2019-04-07T16:21:35.414Z</updated>
    
    <content type="html"><![CDATA[<p>stm32对Cortex内核中断向量表进行重新编排，把编号从-3到6的中断向量定义为系统异常，编号为负的内核异常不能被设置优先级，如-3复位（Reset），-2不可屏蔽中断（NMI），-1硬错误（Hardfault）。编号从7开始为外部中断，优先级可自行设置。</p><a id="more"></a><p><img src="//wangzipai.github.io/posts/32250/1.png" alt></p><p>由于中断太多，配置困难，因此需要中断控制寄存器NVIC。NVIC属于Cortex内核器件，不可屏蔽中断和外部中断都由它处理，<strong><em>systick不是由他控制的</em></strong>。</p><h4 id="中断管理方法"><a href="#中断管理方法" class="headerlink" title="中断管理方法"></a>中断管理方法</h4><p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。由于NVIC只能配置16种中断向量的优先级，也就是说抢占优先级和响应优先级的数量由一个4位的数字来决定，把这个4位数字的位数配置成抢占优先级和响应优先级有5组分配式。分组配置是在寄存器SCB-&gt;AIRCR中配置。一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</p><h5 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数"></a>中断优先级分组函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</span><br><span class="line">  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(<span class="name">NVIC_PriorityGroup_2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="中断优先级设置"><a href="#中断优先级设置" class="headerlink" title="中断优先级设置"></a>中断优先级设置</h3><p>分组设置好之后，设置单个中断的抢占优先级和响应优先级</p><h4 id="中断设置相关寄存器"><a href="#中断设置相关寄存器" class="headerlink" title="中断设置相关寄存器"></a>中断设置相关寄存器</h4><p>__IO uint8_t  IP[240]; //中断优先级控制的寄存器组</p><p>__IO uint32_t ISER[8]; //中断使能寄存器组。用来使能中断。</p><p>__IO uint32_t ICER[8]; //中断失能寄存器组。作用：用来失能中断。</p><p>__IO uint32_t ISPR[8]; //中断挂起寄存器组。作用：用来挂起中断。</p><p>__IO uint32_t ICPR[8]; //中断解挂寄存器组。作用：用来解挂中断。</p><p>__IO uint32_t IABR[8]; //中断激活标志位寄存器组。作用：只读，通过它可以知道当前在执行的中断是哪一个，如果对应位为1，说明该中断正在执行。</p><h4 id="MDK中NVIC寄存器结构体"><a href="#MDK中NVIC寄存器结构体" class="headerlink" title="MDK中NVIC寄存器结构体"></a>MDK中NVIC寄存器结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ISER[<span class="number">8</span>];             </span><br><span class="line">       <span class="keyword">uint32_t</span> RESERVED0[<span class="number">24</span>];                                   </span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ICER[<span class="number">8</span>];                    </span><br><span class="line">       <span class="keyword">uint32_t</span> RSERVED1[<span class="number">24</span>];                                    </span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ISPR[<span class="number">8</span>];                     </span><br><span class="line">       <span class="keyword">uint32_t</span> RESERVED2[<span class="number">24</span>];                                   </span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ICPR[<span class="number">8</span>];                   </span><br><span class="line">       <span class="keyword">uint32_t</span> RESERVED3[<span class="number">24</span>];                                   </span><br><span class="line">  __IO <span class="keyword">uint32_t</span> IABR[<span class="number">8</span>];                     </span><br><span class="line">       <span class="keyword">uint32_t</span> RESERVED4[<span class="number">56</span>];                                   </span><br><span class="line">  __IO <span class="keyword">uint8_t</span>  IP[<span class="number">240</span>];                     </span><br><span class="line">       <span class="keyword">uint32_t</span> RESERVED5[<span class="number">644</span>];                                  </span><br><span class="line">  __O  <span class="keyword">uint32_t</span> STIR;                         </span><br><span class="line">&#125;  NVIC_Type;</span><br></pre></td></tr></table></figure><p>中断优先级控制的寄存器组：IP[240] 。作用：设置每个中断优先级。全称是：Interrupt Priority Registers。240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F10x系列一共60个可屏蔽中断，使用IP[59]~IP[0]。每个IP寄存器的高4位用来设置抢占和响应优先级（根据分组），低4位没有用到。</p><p>中断使能寄存器组：ISER[8]。作用：用来使能中断。32位寄存器，每个位控制一个中断的使能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ISER[0]和ISER[1]。ISER[0]的bit0~bit31分别对应中断0~31。ISER[1]的bit0~27对应中断32~59；</p><p>中断失能寄存器组：ICER[8]。作用：用来失能中断。32位寄存器，每个位控制一个中断的失能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ICER[0]和ICER[1]。ICER[0]的bit0~bit31分别对应中断0~31。ICER[1]的bit0~27对应中断32~59；配置方法跟ISER一样。</p><h4 id="中断参数初始化函数"><a href="#中断参数初始化函数" class="headerlink" title="中断参数初始化函数"></a>中断参数初始化函数</h4><p><code>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//设置中断通道</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority;<span class="comment">//设置响应优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//设置抢占优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//使能/使能</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//串口1中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span> ;<span class="comment">// 抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;<span class="comment">// 子优先级位2</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);//根据上面指定的参数初始化NVIC寄存器</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;stm32对Cortex内核中断向量表进行重新编排，把编号从-3到6的中断向量定义为系统异常，编号为负的内核异常不能被设置优先级，如-3复位（Reset），-2不可屏蔽中断（NMI），-1硬错误（Hardfault）。编号从7开始为外部中断，优先级可自行设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>systick滴答定时器</title>
    <link href="https://wangzipai.github.io/posts/36388/"/>
    <id>https://wangzipai.github.io/posts/36388/</id>
    <published>2019-03-28T13:41:06.000Z</published>
    <updated>2019-03-30T06:53:28.134Z</updated>
    
    <content type="html"><![CDATA[<p>Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，即一次最多可以计数2的24次方个时钟脉冲，这个脉冲计数值被保存到SysTick 当前值寄存器 STK_VAL中，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。<strong><em>只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作</em>。</strong>当然要使用Ststick进行工作必须要进行Systick配置。他的控制配置很简单，只有3个控制位和1个标志位，都在STK_CTRL中。</p><p>在所有CM3产品中，Systick定时器的处理方式都是相同的。不过，STCLK的具体的来源则由芯片设计者决定，因此不同产品之间的时钟频率可能大不相同。如果使用中发现延时不一致，问题一般都是因为不同内核时钟不一样而已。修改ticks值即可。</p><a id="more"></a><p>Systick有4个寄存器</p><p>CTRL              SysTick 控制和状态寄存器 </p><p><img src="//wangzipai.github.io/posts/36388/Systick控制和状态寄存器.png" alt></p><p>LOAD             SysTick 自动重装载除值寄存器 </p><p><img src="//wangzipai.github.io/posts/36388/SysTick 重装载数值寄存器.png" alt></p><p>VAL                SysTick 当前值寄存器  </p><p><img src="//wangzipai.github.io/posts/36388/SysTick 当前值寄存器.png" alt></p><p>CALIB            SysTick 校准值寄存器</p><hr><p>固件库中的Systick相关函数：</p><p>1.SysTick_CLKSourceConfig()    //Systick时钟源选择  misc.c文件中</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));</span><br><span class="line">  <span class="keyword">if</span> (SysTick_CLKSource == SysTick_CLKSource_HCLK)</span><br><span class="line">  &#123;</span><br><span class="line">    S<span class="function"><span class="title">ysTick</span>-&gt;</span>CTRL |= SysTick_CLKSource_HCLK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    S<span class="function"><span class="title">ysTick</span>-&gt;</span>CTRL &amp;= SysTick_CLKSource_HCLK_Div8;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择时钟源，外部时钟源（STCLK，等于HCLK/8），另一个是内核时钟（FCLK，等于HCLK）。</p><ol start="2"><li>SysTick_Config(uint32_t ticks) //初始化systick,时钟为HCLK,并开启中断 //core_cm3.h/core_cm4.h文件中</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@brief</span>  Initialize and start the SysTick counter and its interrupt.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   ticks   number of ticks between two interrupts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  1 = failed, 0 = successful</span></span><br><span class="line"><span class="comment"> * Initialise the system tick timer and its interrupt and start the</span></span><br><span class="line"><span class="comment"> * system tick timer / counter in free running mode to generate </span></span><br><span class="line"><span class="comment"> * periodical interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __INLINE uint32_t SysTick_Config(uint32_t ticks)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="keyword">return</span> (<span class="number">1</span>);         <span class="comment">/* Reload value impossible */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* set reload register */</span>                                                            </span><br><span class="line">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="number">1</span>; </span><br><span class="line"><span class="comment">/* set Priority for Cortex-M0 System Interrupts */</span></span><br><span class="line">  NVIC_SetPriority (SysTick_IRQn, (<span class="number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="number">1</span>); </span><br><span class="line">  SysTick-&gt;VAL   = <span class="number">0</span>;                                        <span class="comment">/* Load the SysTick Counter Value */</span></span><br><span class="line">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class="line">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class="line">                   SysTick_CTRL_ENABLE_Msk;     <span class="comment">/* Enable SysTick IRQ and SysTick Timer */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ticks：两个中断之间的脉冲数，即相隔多少个时钟周期会引起一次中断</p><p>SysTick_LOAD_RELOAD_Msk：SysTick上限，大于这个值返回1（failed）。</p><p><code>SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1;</code>-1是因为向下计数至0。</p><p>systick定时器有两个可选的时钟源，一个是外部时钟源（STCLK，等于HCLK/8），另一个是内核时钟（FCLK，等于HCLK）。假若你选择内核时钟，并将HCLK频率设置为72MHz的话，<a href="https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">系统时钟</a>周期为1/(72M)；systick有一个24位的递减计数器，每个<a href="https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">系统时钟</a>周期计数器值减一，那么当计数器减到零时，时间经过了：系统时钟周期<em>计数器初值。当你将计数器初值设为72000时（有些例程里面设为71999，其实没什么影响，误差极小），当计数器值减到0时经过了1/(72M)</em>72000=0.001s，即1ms。</p><p>Systick中断服务函数：</p><p>void SysTick_Handler(void);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TimingDelay != <span class="number">0x00</span>) </span><br><span class="line">     &#123; </span><br><span class="line">       TimingDelay--;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最后就是原子给的delay.h头文件里的函数了，刚开始时就对这个头文件很感兴趣了，觉得这是一个应用范围很广的东西，原来是用systick写的。因为还没学os,忽略。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void delay_init()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS  <span class="comment">//如果需要支持OS.</span></span></span><br><span class="line">u32 <span class="built_in">reload</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);<span class="comment">//选择外部时钟  HCLK/8</span></span><br><span class="line">fac_us=SystemCoreClock/<span class="number">8000000</span>;<span class="comment">//为系统时钟的1/8  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS  <span class="comment">//如果需要支持OS.</span></span></span><br><span class="line"><span class="built_in">reload</span>=SystemCoreClock/<span class="number">8000000</span>;<span class="comment">//每秒钟的计数次数 单位为M  </span></span><br><span class="line"><span class="built_in">reload</span>*=<span class="number">1000000</span>/delay_ostickspersec;<span class="comment">//根据delay_ostickspersec设定溢出时间</span></span><br><span class="line"><span class="comment">//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右</span></span><br><span class="line">fac_ms=<span class="number">1000</span>/delay_ostickspersec;<span class="comment">//代表OS可以延时的最少单位   </span></span><br><span class="line"></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk;   <span class="comment">//开启SYSTICK中断</span></span><br><span class="line">SysTick-&gt;<span class="built_in">LOAD</span>=<span class="built_in">reload</span>; <span class="comment">//每1/delay_ostickspersec秒中断一次</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk;   <span class="comment">//开启SYSTICK    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">fac_ms=(u16)fac_us*<span class="number">1000</span>;<span class="comment">//非OS下,代表每个ms需要的systick时钟数   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_SUPPORT_OS  <span class="comment">//如果需要支持OS.</span></span></span><br><span class="line"><span class="comment">//延时nus</span></span><br><span class="line"><span class="comment">//nus为要延时的us数.</span></span><br></pre></td></tr></table></figure><p>初始化的语句，即sysclk=72，fac_us=9(无单位)。外部晶振为8MHZ， systick的时钟为外部时钟的1/8，所以systick（系统时钟）为9MHZ。系统运行9M次耗时1s，因此运行9次耗时1us。<br>fac_us没有单位，它只是在重装初值时起到作用，比如Systick-&gt;LOAD=nus*fac_us.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void delay_us(<span class="built_in">u32</span> nus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">u32</span> temp;     </span><br><span class="line">SysTick-&gt;LOAD=nus*fac_us; <span class="comment">//时间加载   </span></span><br><span class="line">SysTick-&gt;VAL=<span class="number">0x00</span>;        <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;<span class="comment">//开始倒数  </span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;<span class="keyword">while</span>((temp&amp;<span class="number">0x01</span>)&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;<span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0</span>X00;       <span class="comment">//清空计数器 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时nms</span></span><br><span class="line"><span class="comment">//注意nms的范围</span></span><br><span class="line"><span class="comment">//SysTick-&gt;LOAD为24位寄存器,所以,最大延时为:</span></span><br><span class="line"><span class="comment">//nms&lt;=0xffffff*8*1000/SYSCLK</span></span><br><span class="line"><span class="comment">//SYSCLK单位为Hz,nms单位为ms</span></span><br><span class="line"><span class="comment">//对72M条件下,nms&lt;=1864</span></span><br></pre></td></tr></table></figure><p>bit0位为使能位，bit16位为计数标志countflag<br>while(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16)));//当使能位没有被置0并且countflag为0（没数完）， 然后一直执行<a href="https://www.baidu.com/s?wd=DO&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">DO</a>里的语句，用来延时。</p><hr><p>利用systick进行时间测量</p><p>当我们开启systick定时器后，定时器开始工作，我们可以定义一个变量a来对中断次数进行记录，在定时器进入中断时这个变量就a++，当我们关闭定时器后，将变量的数值乘以定时器的中断周期就是测量的时间。一般利用该功能测量程序的时间，特别是涉及算法的程序，对优化算法有非常大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，即一次最多可以计数2的24次方个时钟脉冲，这个脉冲计数值被保存到SysTick 当前值寄存器 STK_VAL中，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。&lt;strong&gt;&lt;em&gt;只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作&lt;/em&gt;。&lt;/strong&gt;当然要使用Ststick进行工作必须要进行Systick配置。他的控制配置很简单，只有3个控制位和1个标志位，都在STK_CTRL中。&lt;/p&gt;
&lt;p&gt;在所有CM3产品中，Systick定时器的处理方式都是相同的。不过，STCLK的具体的来源则由芯片设计者决定，因此不同产品之间的时钟频率可能大不相同。如果使用中发现延时不一致，问题一般都是因为不同内核时钟不一样而已。修改ticks值即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32时钟系统和SystemInit函数解读</title>
    <link href="https://wangzipai.github.io/posts/18156/"/>
    <id>https://wangzipai.github.io/posts/18156/</id>
    <published>2019-03-27T11:11:03.000Z</published>
    <updated>2019-03-27T13:20:20.553Z</updated>
    
    <content type="html"><![CDATA[<h3 id="STM32系统时钟总结"><a href="#STM32系统时钟总结" class="headerlink" title="STM32系统时钟总结"></a>STM32系统时钟总结</h3><p>1 STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。</p><p>   ①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br>   ②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。<br>   ③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。WDG<br>   ④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC<br>   ⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。</p><a id="more"></a><p>2 系统时钟SYSCLK可来源于三个时钟源：<br> ①、HSI振荡器时钟</p><p> ②、HSE振荡器时钟</p><p> ③、PLL时钟</p><p>3 STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。</p><p>4 任何一个外设在使用之前，必须首先使能其相应的时钟。</p><p><img src="//wangzipai.github.io/posts/18156/STM32F10xx时钟系统框图.png" alt></p><p>内部时钟是由芯片内部RC震荡器产生得的，起针较快，所以时钟在芯片刚上电的时候，默认使用内部高速时钟。而外部时钟信号是由外部晶振输入的，在精度和稳定性上都有很大优势，所以上电之后在通过软件配置，转而用外部时钟信号。</p><h3 id="RCC相关头文件和固件库源文件"><a href="#RCC相关头文件和固件库源文件" class="headerlink" title="RCC相关头文件和固件库源文件"></a>RCC相关头文件和固件库源文件</h3><p>1.<strong>时钟使能配置</strong></p><p>​      <em>RCC_LSEConfig()</em> <em>、<strong>RCC_HSEConfig</strong>()、</em></p><p>​      <em>RCC_HSICmd()</em> <em>、</em> <em>RCC_LSICmd()</em> <em>、</em> <em>RCC_PLLCmd() ……</em></p><p>2.<strong>时钟源相关配置：</strong></p><p>​      <em>RCC_PLLConfig</em> <em>()、</em> <em>RCC_SYSCLKConfig()</em> <em>、</em></p><p>​     <em>RCC_RTCCLKConfig() …</em></p><p>3.<strong>分频系数选择配置：</strong></p><p>​      <em>RCC_HCLKConfig()</em> <em>、</em> <em>RCC_PCLK1Config()</em> <em>、</em> <em>RCC_PCLK2Config()…</em></p><p>4.<strong>外设时钟使能：</strong></p><p>​      <em>RCC_APB1PeriphClockCmd():</em>  //APB1线上外设时钟使能</p><p>​     <em>RCC_APB2PeriphClockCmd();</em>  //APB2线上外设时钟使能</p><p>​     <em>RCC_AHBPeriphClockCmd**();</em>   //AHB线上外设时钟使能</p><p><strong>5.</strong>  <strong>其他外设时钟配置：</strong></p><p>​     <em>RCC_ADCCLKConfig</em> <em>();</em>  <em>RCC_RTCCLKConfig();</em></p><p>6.<strong>状态参数获取参数：</strong></p><p>​     <em>RCC_GetClocksFreq();</em></p><p>​     <em>RCC_GetSYSCLKSource();</em></p><p>​     RCC_GetFlagStatus()</p><p>7.<strong>RCC中断相关函数:</strong></p><p>​     RCC_ITConfig() <em>、</em> <em>RCC_GetITStatus()</em> <em>、</em> <em>RCC_ClearITPendingBit()…</em></p><h3 id="SystemInit函数"><a href="#SystemInit函数" class="headerlink" title="SystemInit函数"></a>SystemInit函数</h3><p>在startup_stm32f10x_hd.s启动文件中，有一段启动代码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Reset_Handler</span>   <span class="meta">PROC</span></span><br><span class="line">                <span class="meta">EXPORT</span>  Reset_Handler             [WEAK]</span><br><span class="line">                <span class="meta">IMPORT</span>  __main</span><br><span class="line">                <span class="meta">IMPORT</span>  SystemInit</span><br><span class="line">                <span class="keyword">LDR </span>    <span class="built_in">R0</span>, <span class="symbol">=SystemInit</span></span><br><span class="line">                <span class="keyword">BLX </span>    <span class="built_in">R0</span>               </span><br><span class="line">                <span class="keyword">LDR </span>    <span class="built_in">R0</span>, <span class="symbol">=__main</span></span><br><span class="line">                <span class="keyword">BX </span>     <span class="built_in">R0</span></span><br><span class="line">                <span class="meta">ENDP</span></span><br></pre></td></tr></table></figure><p>当芯片被复位时，将开始运行这一段代码，运行过程是先调用SystemInit（）函数，在进入C语言中的“__main”函数执行（不是main），这是一个C标准库的初始化函数，执行这个函数后，最终跳转到用户文件的“main”函数入口，开始运行主函数。</p><p>SystemInit（）函数，定义在system_stm32f10x.c中，他的作用是设置系统时钟SYSCLK</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Reset the RCC clock configuration to the default reset state(for debug purpose) */</span></span><br><span class="line">  <span class="comment">/* Set HSION bit 打开内部8MHz震荡器*/</span></span><br><span class="line">  RCC-&gt;CR |= (<span class="keyword">uint32_t</span>)<span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STM32F10X_CL</span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xF8FF0000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xF0FF0000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span>   </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xFEF6FFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEBYP bit */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xFFFBFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span></span><br><span class="line">  RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xFF80FFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STM32F10X_CL</span></span><br><span class="line">  <span class="comment">/* Reset PLL2ON and PLL3ON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="keyword">uint32_t</span>)<span class="number">0xEBFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x00FF0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR2 register */</span></span><br><span class="line">  RCC-&gt;CFGR2 = <span class="number">0x00000000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)</span></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x009F0000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR2 register */</span></span><br><span class="line">  RCC-&gt;CFGR2 = <span class="number">0x00000000</span>;      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Disable all interrupts and clear pending bits  */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x009F0000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> DATA_IN_ExtSRAM</span></span><br><span class="line">    SystemInit_ExtMemCtl(); </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* DATA_IN_ExtSRAM */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */</span></span><br><span class="line">  <span class="comment">/* Configure the Flash Latency cycles and enable prefetch buffer */</span></span><br><span class="line">  SetSysClock();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetSysClock()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSysClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SYSCLK_FREQ_HSE</span></span><br><span class="line">  SetSysClockToHSE();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined SYSCLK_FREQ_24MHz</span></span><br><span class="line">  SetSysClockTo24();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined SYSCLK_FREQ_36MHz</span></span><br><span class="line">  SetSysClockTo36();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined SYSCLK_FREQ_48MHz</span></span><br><span class="line">  SetSysClockTo48();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined SYSCLK_FREQ_56MHz</span></span><br><span class="line">  SetSysClockTo56();  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined SYSCLK_FREQ_72MHz</span></span><br><span class="line">  SetSysClockTo72();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为前面定义默认时钟为72MHz,所以SetSysClockTo72()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSysClockTo72</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> StartUpCounter = <span class="number">0</span>, HSEStatus = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class="line">  <span class="comment">/* Enable HSE */</span>    </span><br><span class="line">  RCC-&gt;CR |= ((<span class="keyword">uint32_t</span>)RCC_CR_HSEON);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class="line">    StartUpCounter++;  </span><br><span class="line">  &#125; <span class="keyword">while</span>((HSEStatus == <span class="number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HSEStatus == (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable Prefetch Buffer */</span></span><br><span class="line">    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flash 2 wait state cpu比flash快，等待flash */</span></span><br><span class="line">    FLASH-&gt;ACR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class="line">    FLASH-&gt;ACR |= (<span class="keyword">uint32_t</span>)FLASH_ACR_LATENCY_2;    </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* HCLK = SYSCLK */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* PCLK2 = HCLK */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PCLK1 = HCLK/2 */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STM32F10X_CL</span></span><br><span class="line">    <span class="comment">/* Configure PLLs ------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */</span></span><br><span class="line">    <span class="comment">/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */</span></span><br><span class="line">        </span><br><span class="line">    RCC-&gt;CFGR2 &amp;= (<span class="keyword">uint32_t</span>)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |</span><br><span class="line">                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);</span><br><span class="line">    RCC-&gt;CFGR2 |= (<span class="keyword">uint32_t</span>)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |</span><br><span class="line">                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Enable PLL2 */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLL2ON;</span><br><span class="line">    <span class="comment">/* Wait till PLL2 is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */</span> </span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | </span><br><span class="line">                            RCC_CFGR_PLLMULL9); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>    </span></span><br><span class="line">    <span class="comment">/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |</span><br><span class="line">                                        RCC_CFGR_PLLMULL));</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable PLL */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Select PLL as system clock source */</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is used as system clock source */</span></span><br><span class="line">    <span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="keyword">uint32_t</span>)RCC_CFGR_SWS) != (<span class="keyword">uint32_t</span>)<span class="number">0x08</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">/* If HSE fails to start-up, the application will have wrong clock </span></span><br><span class="line"><span class="comment">         configuration. User can add here some code to deal with this error */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>对照中文参考手册和时钟框图还挺好理解的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;STM32系统时钟总结&quot;&gt;&lt;a href=&quot;#STM32系统时钟总结&quot; class=&quot;headerlink&quot; title=&quot;STM32系统时钟总结&quot;&gt;&lt;/a&gt;STM32系统时钟总结&lt;/h3&gt;&lt;p&gt;1 STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。&lt;/p&gt;
&lt;p&gt;   ①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。&lt;br&gt;   ②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。&lt;br&gt;   ③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。WDG&lt;br&gt;   ④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC&lt;br&gt;   ⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>GPIO_KEY实验笔记</title>
    <link href="https://wangzipai.github.io/posts/11950/"/>
    <id>https://wangzipai.github.io/posts/11950/</id>
    <published>2019-03-26T14:32:08.000Z</published>
    <updated>2019-03-26T15:35:08.620Z</updated>
    
    <content type="html"><![CDATA[<p>本来觉得这次实验比较简单，就不写了，然而好像太高估自己了。。</p><p>首先是对比自己写的代码和给的源码，发现源码比我多了一行</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">GPIO_PinRemapConfig</span>(GPIO_Remap_SWJ_JTAGDisable, ENABLE);<span class="comment">//关闭jtag，使能SWD，可以用SWD模式调试</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>注释前后，对实验好像没影响。看了一下网上的说法，大概是这样的：</p><p>STM32F10x系列的MCU复位后，PA13/14/15 &amp; PB3/4默认配置为JTAG功能。有时我们为了充分利用MCU I/O口的资源，会把这些端口设置为普通I/O口。</p><p>而KEY0的IO口恰好是PA15。</p><hr><p>然后是KEY_Scan()这个函数的写法，源码实在是太简洁而严谨了，感觉自己还差的很多啊。还有就是关于static这个关键字，让我发现之前关于C语言的一些深入的知识已经不太记得了，需要重新系统的学习一遍。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">u8 KEY_Scan(u8 mode)</span><br><span class="line">&#123;</span><br><span class="line">static u8 key_up = 1;</span><br><span class="line"><span class="keyword">if</span> (mode) key_up = 1;</span><br><span class="line"><span class="keyword">if</span> (key_up &amp;&amp; (<span class="attribute">KEY1</span>==0 || <span class="attribute">KEY0</span>==0 || <span class="attribute">WK_UP</span>==1)) </span><br><span class="line">&#123;</span><br><span class="line">delay_ms(10);</span><br><span class="line">key_up = 0;</span><br><span class="line"><span class="keyword">if</span> (<span class="attribute">KEY1</span>==0) return KEY1_ON;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="attribute">KEY0</span>==0) return KEY0_ON;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="attribute">WK_UP</span>==1) return WKUP_ON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="attribute">KEY1</span>==1 &amp;&amp; <span class="attribute">KEY0</span>==1 &amp;&amp; <span class="attribute">WK_UP</span>==0) key_up = 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来觉得这次实验比较简单，就不写了，然而好像太高估自己了。。&lt;/p&gt;
&lt;p&gt;首先是对比自己写的代码和给的源码，发现源码比我多了一行&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;GPIO_PinRemapConfig&lt;/span&gt;(GPIO_Remap_SWJ_JTAGDisable, ENABLE);&lt;span class=&quot;comment&quot;&gt;//关闭jtag，使能SWD，可以用SWD模式调试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
      <category term="笔记" scheme="https://wangzipai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>延时消抖</title>
    <link href="https://wangzipai.github.io/posts/48277/"/>
    <id>https://wangzipai.github.io/posts/48277/</id>
    <published>2019-03-25T14:14:59.000Z</published>
    <updated>2019-03-26T15:34:48.222Z</updated>
    
    <content type="html"><![CDATA[<p>Key_Scan()函数中有一段代码</p><a id="more"></a><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GPIO<span class="number">_</span>ReadInputDataBit(GPIOx,GPIO<span class="number">_P</span><span class="keyword">in</span>) == KEY<span class="number">_</span>ON)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*延时消抖*/</span></span><br><span class="line">    Delay(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> (GPIO<span class="number">_</span>ReadInputDataBit(GPIOx,GPIO<span class="number">_P</span><span class="keyword">in</span>) == KEY<span class="number">_</span>ON)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (GPIO<span class="number">_</span>ReadInputDataBit(GPIOx,GPIO<span class="number">_P</span><span class="keyword">in</span>) == KEY<span class="number">_</span>ON);</span><br><span class="line">        <span class="keyword">return</span> KEY<span class="number">_</span>ON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> KEY<span class="number">_</span>OFF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> KEY<span class="number">_</span>OFF;</span><br></pre></td></tr></table></figure><p>好奇什么是延时消抖，为什么有2条重复的代码<code>if (GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON)</code></p><p>百度百科说：按键消抖通常的按键所用开关为机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开。因而在闭合及断开的瞬间均伴随有一连串的抖动，为了不产生这种现象而作的措施就是按键消抖。</p><p><img src="//wangzipai.github.io/posts/48277/1.jpg" alt></p><p>所以，Key_Scan()才要读取2次GPIO_ReadInputDataBit读取的数据。键抖动会引起一次按键被误读多次。为确保CPU对键的一次闭合仅作一次处理，必须去除键抖动。在键闭合稳定时读取键的状态，并且必须判别到键释放稳定后再作处理。</p><p>抖动时间:抖动时间的长短由按键的机械特性决定，一般为5ms～10ms。这是一个很重要的时间参数，在很多场合都要用到。按键稳定闭合时间的长短则是由操作人员的按键动作决定的，一般为零点几秒至数秒。参照这个老哥的说法<a href="https://blog.csdn.net/xu8023636/article/details/79219880" target="_blank" rel="noopener">nickqiang</a>，这个参数应该挺准确的</p><hr><p>然并软，这样的消抖在实际的工程应用并无价值，在实际的工程应用中，是使用一个周期中断函数，每隔一段时间调用该函数来检测设备所有按键，把按下的键用不同的全局变量记录下来。在检测时也是使用短暂延时来消抖（滤波）。</p><p>像上面那样消抖，可以达到去抖的目的，但是实现方式太过暴力，在延时的时候一直占用cpu的资源，如果在延时的时候，有其他外部中断或者抢占事件，系统完全没有响应的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key_Scan()函数中有一段代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
      <category term="笔记" scheme="https://wangzipai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>stm32蜂鸣器实验总结</title>
    <link href="https://wangzipai.github.io/posts/31496/"/>
    <id>https://wangzipai.github.io/posts/31496/</id>
    <published>2019-03-24T12:18:21.000Z</published>
    <updated>2019-03-25T11:54:41.616Z</updated>
    
    <content type="html"><![CDATA[<p>由于家境贫寒只买得起mini版的缘故，关于蜂鸣器的实验只能另外买蜂鸣器外设来做实验了。也因此蜂鸣器所使用的IO口可以自定义，并不一定只能用PB.8来做实验。实验中出现了一些小问题，记录下来，以便之后的复习。</p><a id="more"></a><p>首先是在写beef.c的时候，变量的声明放在了可执行语句的后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beep.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BEEP_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">    </span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    </span><br><span class="line">     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">     GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">     </span><br><span class="line">     GPIO_ResetBits(GPIOB,GPIO_Pin_8);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用MDK调试的时候，出现以下错误：</p><p><code>error: #268: declaration may not appear after executablestatement</code></p><p>修改为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "beep.h"</span></span><br><span class="line"><span class="comment">#include "stm32f10x.h"</span></span><br><span class="line"></span><br><span class="line">void <span class="keyword">BEEP_Init(void)&#123;</span></span><br><span class="line"><span class="keyword"> </span>    GPIO_InitTypeDef GPIO_InitStructure<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8<span class="comment">;</span></span><br><span class="line">     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz<span class="comment">;</span></span><br><span class="line">     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP<span class="comment">;</span></span><br><span class="line">     GPIO_Init(GPIOB,&amp;GPIO_InitStructure)<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">     GPIO_ResetBits(GPIOB,GPIO_Pin_8)<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译通过。</p><p>第二个错误是误把<code>RCC_APB2PeriphClockCmd</code>写成<code>RCC_APB2PeriphResetCmd</code>，由于这两个函数前后一样，且<code>RCC_APB2PeriphResetCmd</code>函数在更显眼的地方，以后要注意。</p><p>接下来是关于蜂鸣器实验的一些总结。</p><p>蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电。STM32 开发板板载的蜂鸣器是电磁式的有源蜂鸣器。这里的有源不是指电源的“源”，而是指有没有自带震荡电路，有源蜂鸣器自带了震荡电路，一通电就会发声；无源蜂鸣器则没有自带震荡电路，必须外部提供2~5Khz 左右的方波驱动，才能发声。</p><p>STM32 的单个 IO 最大可以提供 25mA 电流（来自数据手册），而蜂鸣器的驱动电流是 30mA 左右，两者十分相近，但是全盘考虑，STM32 整个芯片的电流，最大也就 150mA，如果用 IO 口直接驱动蜂鸣器，其他地方用电就得省着点了…所以，我们不用 STM32 的 IO 直接驱动蜂鸣器，而是通过三极管扩流后再驱动蜂鸣器，这样<br>STM32 的 IO 只需要提供不到 1mA 的电流就足够了。</p><p>蜂鸣器与 STM32 连接原理图 ：</p><p><img src="//wangzipai.github.io/posts/31496/beef.png" alt="beef"></p><p>图中我们用到一个 NPN 三极管（S8050）来驱动蜂鸣器，R38 主要用于防止蜂鸣器的误发声。当 PB.8 输出高电平的时候，蜂鸣器将发声，当 PB.8 输出低电平的时候，蜂鸣器停止发声。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于家境贫寒只买得起mini版的缘故，关于蜂鸣器的实验只能另外买蜂鸣器外设来做实验了。也因此蜂鸣器所使用的IO口可以自定义，并不一定只能用PB.8来做实验。实验中出现了一些小问题，记录下来，以便之后的复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32的3种开发方式</title>
    <link href="https://wangzipai.github.io/posts/31616/"/>
    <id>https://wangzipai.github.io/posts/31616/</id>
    <published>2019-03-24T04:57:32.000Z</published>
    <updated>2019-03-24T11:35:18.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>stm32有3种不同的开发方式，库函数开发，基于寄存器开发与位带操作。3种方式各有优劣，这里我简单的写一下自己的看法吧。</p><p>在51单片机的程序开发中，我们直接配置寄存器。因为51的功能相对比较简单，对应的寄存器也比较少，所以可以通过配置寄存器的方式开发。到了stm32中，虽然原理相同，但功能多了非常多，寄存器也相对的多了，这时想象51一样记住每个寄存器是不可能的。这时ST公司提供了库函数，开发者只需调用这些函数接口来配置寄存器。</p><p>而这3种方式，本质上都是通过不同的途径，最终实现对相应寄存器的配置。</p><a id="more"></a><h3 id="基于寄存器开发"><a href="#基于寄存器开发" class="headerlink" title="基于寄存器开发"></a>基于寄存器开发</h3><p>直接配置寄存器，可以更直观的了解配置的是那些寄存器以及是如何配置的，同时运行程序是占用资源也更少，代码更加简洁。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LED_Init(void)&#123;</span><br><span class="line"></span><br><span class="line"> RCC-&gt;APB2ENR|<span class="type">=1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line"> RCC-&gt;APB2ENR|<span class="type">=1</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"> //GPIOA<span class="number">.8</span></span><br><span class="line"> GPIOA-&gt;CRH&amp;=<span class="number">0XFFFFFFF0</span>;</span><br><span class="line"> GPIOA-&gt;CRH|<span class="type">=0X00000003</span>;</span><br><span class="line"> GPIOA-&gt;ODR|<span class="type">=1</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line"> //GPIOD<span class="number">.2</span></span><br><span class="line"> GPIOD-&gt;CRL&amp;=<span class="number">0XFFFFF0FF</span>;</span><br><span class="line"> GPIOD-&gt;CRL|<span class="type">=0X00000300</span>;</span><br><span class="line"> GPIOD-&gt;ODR|<span class="type">=1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的方式是内核执行效率最高的方式，然而由于寄存器数量和复杂度的增加，直接配置寄存器的开发速度和程序可读性就下降。</p><h3 id="库函数开发"><a href="#库函数开发" class="headerlink" title="库函数开发"></a>库函数开发</h3><p>库的本质就是建立一个新的软件抽象层，分层使得问题变得简单，屏蔽了底层实现方式的差异，让软件开发变成简单的调用函数。</p><p>从内核的执行效率来看，首先库函数在被调用的时候，要耗费调用的时间，在函数内部，把输入参数转换成直接写入到寄存器的值也耗费了一些运算时间。优点是可以快速上手stm32微控制器，交流方便，查错简单。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void LED_Init (void)</span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD,ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Mode</span>=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Pin</span>=GPIO_Pin_8;</span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Speed</span>=GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_8);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Mode</span>=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Pin</span>=GPIO_Pin_2;</span><br><span class="line">    GPIO_InitStructure.<span class="attribute">GPIO_Speed</span>=GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOD,&amp;GPIO_InitStructure);</span><br><span class="line">    GPIO_SetBits(GPIOD,GPIO_Pin_2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="位带操作（记得引入sys-h头文件）"><a href="#位带操作（记得引入sys-h头文件）" class="headerlink" title="位带操作（记得引入sys.h头文件）"></a>位带操作（记得引入sys.h头文件）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>把每个比特膨胀为一个32位的字，当访问这些字的时候就达到了访问比特的目的，比如说BSRR寄存器有32个位，那么可以映射到32个地址上，我们去访问（读-改-写）这32个地址就达到访问32个比特的目的。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>对硬件I/O密集型的底层程序提供了很大方便，使代码更加简洁。化简跳转的判断。在多任务中实现共享资源在任务间的“互锁”访问。</p><h4 id="支持区域"><a href="#支持区域" class="headerlink" title="支持区域"></a>支持区域</h4><p>其中一个是 SRAM 区的最低 1MB 范围，0x20000000 ‐ 0x200FFFFF（SRAM   区中的最低 1MB）</p><p>第二个则是片内外设区的最低 1MB范围，0x40000000 ‐ 0x400FFFFF（片上外设区中最低 1MB）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define LED0 PAout(<span class="number">8</span>)<span class="comment">// PA8</span></span><br><span class="line">#define LED1 PDout(<span class="number">2</span>)<span class="comment">// PD2</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Stm32_Clock_Init(<span class="number">9</span>); <span class="comment">//系统时钟设置</span></span><br><span class="line">    delay_init(<span class="number">72</span>);     <span class="comment">//延时初始化</span></span><br><span class="line">    LED_Init();   <span class="comment">//初始化与LED连接的硬件接口    </span></span><br><span class="line">    while(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0=<span class="number">0</span>;</span><br><span class="line">        LED1=<span class="number">1</span>;</span><br><span class="line">        delay_ms(<span class="number">300</span>);</span><br><span class="line">        LED0=<span class="number">1</span>;</span><br><span class="line">        LED1=<span class="number">0</span>;</span><br><span class="line">        delay_ms(<span class="number">300</span>);</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>随着处理器性能的不断提升，库函数开发会成为趋势，但寄存器可以对原理有更深入的了解。库和寄存器交叉学习，开发用库，然后慢慢深入，加深理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;stm32有3种不同的开发方式，库函数开发，基于寄存器开发与位带操作。3种方式各有优劣，这里我简单的写一下自己的看法吧。&lt;/p&gt;
&lt;p&gt;在51单片机的程序开发中，我们直接配置寄存器。因为51的功能相对比较简单，对应的寄存器也比较少，所以可以通过配置寄存器的方式开发。到了stm32中，虽然原理相同，但功能多了非常多，寄存器也相对的多了，这时想象51一样记住每个寄存器是不可能的。这时ST公司提供了库函数，开发者只需调用这些函数接口来配置寄存器。&lt;/p&gt;
&lt;p&gt;而这3种方式，本质上都是通过不同的途径，最终实现对相应寄存器的配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客的玄学加速</title>
    <link href="https://wangzipai.github.io/posts/50535/"/>
    <id>https://wangzipai.github.io/posts/50535/</id>
    <published>2019-03-22T09:56:41.000Z</published>
    <updated>2019-03-22T10:49:28.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>利用 InstantClick、hexo-service-worker、hexo-filter-optimize 加速博客</p><h3 id="InstantClick"><a href="#InstantClick" class="headerlink" title="InstantClick"></a>InstantClick</h3><p>InstantClick是一个JavaScript库，可以通过预加载显着加快网站的速度。先下载压缩版的 <a href="http://instantclick.io/v3.1.0/instantclick.min.js" target="_blank" rel="noopener">instantclick.min.js</a>（浏览器右键保存为），再放到<code>~/next/source/js/src/</code>下，然后添加代码：</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>= <span class="string">"/js/src/instantclick.min.js"</span> <span class="attr">data-no-instant</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-no-instant</span>&gt;</span><span class="undefined">InstantClick.init();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>去除顶部加载条：</p><p>在<code>next/source/css/_custom/custom.styl</code>文件添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#instantclick</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hexo-service-worker"><a href="#hexo-service-worker" class="headerlink" title="hexo-service-worker"></a>hexo-service-worker</h4><p>hexo-service-worker 是一个 hexo 用来让博客拥有 Service Worker 功能的插件，能够默认的把站点中 public 内的所有静态资源包括 html 文件缓存起来，达到离线可访问的效果</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> hexo-service-worker --save</span><br></pre></td></tr></table></figure><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>安装插件后，直接配置 <code>_config.yml</code> 文件如下就可以了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># offline config passed to sw-precache.</span></span><br><span class="line"><span class="attr">service_worker:</span></span><br><span class="line"><span class="attr">  maximumFileSizeToCacheInBytes:</span> <span class="number">5242880</span></span><br><span class="line"><span class="attr">  staticFileGlobs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">public/**/*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125;</span></span><br><span class="line"><span class="attr">  stripPrefix:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">  verbose:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="hexo-filter-optimize"><a href="#hexo-filter-optimize" class="headerlink" title="hexo-filter-optimize"></a>hexo-filter-optimize</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-filter-<span class="keyword">optimize</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h5><p>安装插件后，直接配置 <code>_config.yml</code> 文件如下就可以了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filter_optimize:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># remove static resource query string</span></span><br><span class="line">  <span class="comment">#   - like `?v=1.0.0`</span></span><br><span class="line"><span class="attr">  remove_query_string:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># remove the surrounding comments in each of the bundled files</span></span><br><span class="line"><span class="attr">  remove_comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  css:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># bundle loaded css file into the one</span></span><br><span class="line"><span class="attr">    bundle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># use a script block to load css elements dynamically</span></span><br><span class="line"><span class="attr">    delivery:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># make specific css content inline into the html page</span></span><br><span class="line">    <span class="comment">#   - only support the full path</span></span><br><span class="line">    <span class="comment">#   - default is ['css/main.css']</span></span><br><span class="line"><span class="attr">    inlines:</span></span><br><span class="line"><span class="attr">    excludes:</span></span><br><span class="line"><span class="attr">  js:</span></span><br><span class="line">    <span class="comment"># bundle loaded js file into the one</span></span><br><span class="line"><span class="attr">    bundle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    excludes:</span></span><br><span class="line">  <span class="comment"># set the priority of this plugin,</span></span><br><span class="line">  <span class="comment"># lower means it will be executed first, default is 10</span></span><br><span class="line"><span class="attr">  priority:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="修复网页图标不显示"><a href="#修复网页图标不显示" class="headerlink" title="修复网页图标不显示"></a>修复网页图标不显示</h3><p>在主题配置文件中，让fontawesome 使用 cdn 即可，搜索fontawesome，修改如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Internal version: 4.6.2</span></span><br><span class="line">  <span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line">  fontawesome: http:<span class="regexp">//m</span>axcdn.bootstrapcdn.com<span class="regexp">/font-awesome/</span><span class="number">4.6</span>.<span class="number">2</span><span class="regexp">/css/</span>font-awesome.min.css</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;利用 InstantClick、hexo-service-worker、hexo-filter-optimize 加速博客&lt;/p&gt;
&lt;h3 id=&quot;InstantClick&quot;&gt;&lt;a href=&quot;#InstantClick&quot; class=&quot;headerlink&quot; title=&quot;InstantClick&quot;&gt;&lt;/a&gt;InstantClick&lt;/h3&gt;&lt;p&gt;InstantClick是一个JavaScript库，可以通过预加载显着加快网站的速度。先下载压缩版的 &lt;a href=&quot;http://instantclick.io/v3.1.0/instantclick.min.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;instantclick.min.js&lt;/a&gt;（浏览器右键保存为），再放到&lt;code&gt;~/next/source/js/src/&lt;/code&gt;下，然后添加代码：&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://wangzipai.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>GPIO_Init源码及注释</title>
    <link href="https://wangzipai.github.io/posts/53676/"/>
    <id>https://wangzipai.github.io/posts/53676/</id>
    <published>2019-03-20T15:26:08.000Z</published>
    <updated>2019-03-22T18:26:53.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="GPIO-Init源码及注释"><a href="#GPIO-Init源码及注释" class="headerlink" title="GPIO_Init源码及注释"></a>GPIO_Init源码及注释</h4><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span><span class="comment">//把GPIOx的地址转换为GPIO_TypeDef结构体指针类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> currentmode = <span class="number">0x00</span>, currentpin = <span class="number">0x00</span>, pinpos = <span class="number">0x00</span>, pos = <span class="number">0x00</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line">  <span class="comment">/* 断言，用于检查输入的参数是否正确 */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_MODE(GPIO_InitStruct-&gt;GPIO_Mode));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_InitStruct-&gt;GPIO_Pin));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*---------------------------- GPIO的模式配置 -----------------------*/</span></span><br><span class="line"><span class="comment">/*把输入参数GPIO_Mode的低四位暂存在currentmode*/</span></span><br><span class="line">  currentmode = ((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="keyword">uint32_t</span>)<span class="number">0x0F</span>);</span><br><span class="line"><span class="comment">/*判断是否为输出模式，若是输出模式，可输入参数中输出模式的bit4位都是1</span></span><br><span class="line"><span class="comment">typedef enum</span></span><br><span class="line"><span class="comment">&#123; GPIO_Mode_AIN = 0x0,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_IN_FLOATING = 0x04,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_IPD = 0x28,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_IPU = 0x48,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_Out_OD = 0x14,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_Out_PP = 0x10,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_AF_OD = 0x1C,</span></span><br><span class="line"><span class="comment">  GPIO_Mode_AF_PP = 0x18</span></span><br><span class="line"><span class="comment">&#125;GPIOMode_TypeDef;</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">  <span class="keyword">if</span> ((((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp; ((<span class="keyword">uint32_t</span>)<span class="number">0x10</span>)) != <span class="number">0x00</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">/* 检查输入参数 */</span></span><br><span class="line">    assert_param(IS_GPIO_SPEED(GPIO_InitStruct-&gt;GPIO_Speed));</span><br><span class="line">    <span class="comment">/* 输出模式，所以要配置GPIO的速率（00（输入模式） 01（10MHz）） 10（2MHz） 11(20MHz) */</span></span><br><span class="line">    currentmode |= (<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class="line">  &#125;<span class="comment">//GPIO_Mode的低四位分别为0000，0100，1000，1100.对速率无影响</span></span><br><span class="line"><span class="comment">/*---------------------------- 配置GPIO的CRL寄存器 ------------------------*/</span></span><br><span class="line">  <span class="comment">/* 判断要配置的是否为pin0~pin7*/</span></span><br><span class="line"><span class="comment">/*#define GPIO_Pin_0    ((uint16_t)0x0001)  /*!&lt; Pin 0 selected */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_1      ((uint16_t)0x0002)  <span class="comment">/*!&lt; Pin 1 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_2      ((uint16_t)0x0004)  <span class="comment">/*!&lt; Pin 2 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_3      ((uint16_t)0x0008)  <span class="comment">/*!&lt; Pin 3 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_4      ((uint16_t)0x0010)  <span class="comment">/*!&lt; Pin 4 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_5      ((uint16_t)0x0020)  <span class="comment">/*!&lt; Pin 5 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_6      ((uint16_t)0x0040)  <span class="comment">/*!&lt; Pin 6 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_7      ((uint16_t)0x0080)  <span class="comment">/*!&lt; Pin 7 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_8      ((uint16_t)0x0100)  <span class="comment">/*!&lt; Pin 8 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_9      ((uint16_t)0x0200)  <span class="comment">/*!&lt; Pin 9 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_10     ((uint16_t)0x0400)  <span class="comment">/*!&lt; Pin 10 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_11     ((uint16_t)0x0800)  <span class="comment">/*!&lt; Pin 11 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_12     ((uint16_t)0x1000)  <span class="comment">/*!&lt; Pin 12 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_13     ((uint16_t)0x2000)  <span class="comment">/*!&lt; Pin 13 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_14     ((uint16_t)0x4000)  <span class="comment">/*!&lt; Pin 14 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_15     ((uint16_t)0x8000)  <span class="comment">/*!&lt; Pin 15 selected*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_All    ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; All pins selected */</span></span></span><br><span class="line">  */</span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp; ((<span class="keyword">uint32_t</span>)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*备份原CRL寄存器的值*/</span></span><br><span class="line">    tmpreg = GPIOx-&gt;CRL;</span><br><span class="line">    <span class="comment">/*循环，一个循环设置一个寄存器位*/</span></span><br><span class="line">    <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*pos的值为1左移pinpos位*/</span></span><br><span class="line">      pos = ((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line">      <span class="comment">/* 令pos与输入参数GPIO_PIN做位与运算，为下面的判断做准备 */</span></span><br><span class="line">      currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line">      <span class="comment">/*判断，若currentpin等于pos，说明GPIO_PIN参数中含的第pos个引脚需要配置*/</span></span><br><span class="line">      <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">/*pos的值左移2位（乘以4），因为寄存器中4个寄存器位配置一个引脚*/</span></span><br><span class="line">        pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">      <span class="comment">/*以下两个句子，把控制这个引脚的4个寄存器位清零，其他寄存器位不变*/</span>  </span><br><span class="line">        <span class="comment">/* Clear the corresponding low control register bits */</span></span><br><span class="line">        pinmask = ((<span class="keyword">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">        tmpreg &amp;= ~pinmask;</span><br><span class="line">        <span class="comment">/* 向寄存器写入将要配置的引脚模式 */</span></span><br><span class="line">        tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line">        <span class="comment">/* 复位GPIO引脚的输入输出默认值 */</span></span><br><span class="line">        <span class="comment">/* 判断是否为下拉输入模式 */</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/*下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置零*/</span></span><br><span class="line">          GPIOx-&gt;BRR = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* 判断是否为上拉输入模式 */</span></span><br><span class="line">          <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">          &#123;</span><br><span class="line">        <span class="comment">/*上拉输入模式，引脚默认置1，对BSRR寄存器写1可对引脚置1*/</span></span><br><span class="line">            GPIOx-&gt;BSRR = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*把前面处理后的暂存值写入CRL寄存器之中*/</span></span><br><span class="line">    GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*---------------------------- GPIO CRH Configuration ------------------------*/</span></span><br><span class="line">  <span class="comment">/* Configure the eight high port pins */</span></span><br><span class="line">  <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    tmpreg = GPIOx-&gt;CRH;</span><br><span class="line">    <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">    &#123;</span><br><span class="line">      pos = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">      <span class="comment">/* Get the port pins position */</span></span><br><span class="line">      currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class="line">      <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">      &#123;</span><br><span class="line">        pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* Clear the corresponding high control register bits */</span></span><br><span class="line">        pinmask = ((<span class="keyword">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">        tmpreg &amp;= ~pinmask;</span><br><span class="line">        <span class="comment">/* Write the mode configuration in the corresponding bits */</span></span><br><span class="line">        tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line">        <span class="comment">/* Reset the corresponding ODR bit */</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">        &#123;</span><br><span class="line">          GPIOx-&gt;BRR = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Set the corresponding ODR bit */</span></span><br><span class="line">        <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">        &#123;</span><br><span class="line">          GPIOx-&gt;BSRR = (((<span class="keyword">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GPIOx-&gt;CRH = tmpreg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;GPIO-Init源码及注释&quot;&gt;&lt;a href=&quot;#GPIO-Init源码及注释&quot; class=&quot;headerlink&quot; title=&quot;GPIO_Init源码及注释&quot;&gt;&lt;/a&gt;GPIO_Init源码及注释&lt;/h4&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://wangzipai.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 I/O口的八种工作模式</title>
    <link href="https://wangzipai.github.io/posts/33448/"/>
    <id>https://wangzipai.github.io/posts/33448/</id>
    <published>2019-03-20T11:39:04.000Z</published>
    <updated>2019-03-25T11:46:24.782Z</updated>
    
    <content type="html"><![CDATA[<p>stm32 I/O口有8种工作模式，分别为4种输入模式和4种输出模式：</p><p>4种输入模式：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO_Mode_AIN 模拟输入 </span><br><span class="line">（<span class="number">2</span>）GPIO_Mode_IN_FLOATING 浮空输入 </span><br><span class="line">（<span class="number">3</span>）GPIO_Mode_IPD 下拉输入 </span><br><span class="line">（<span class="number">4</span>）GPIO_Mode_IPU 上拉输入</span><br></pre></td></tr></table></figure><a id="more"></a><p>4种输出模式：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">5</span>）GPIO_Mode_Out_OD 开漏输出 </span><br><span class="line">（<span class="number">6</span>）GPIO_Mode_Out_PP 推挽输出 </span><br><span class="line">（<span class="number">7</span>）GPIO_Mode_AF_OD 复用开漏输出 </span><br><span class="line">（<span class="number">8</span>）GPIO_Mode_AF_PP 复用推挽输出</span><br></pre></td></tr></table></figure><p>那么这8种工作模式具体的含义是什么呢？</p><p>浮空,顾名思义就是浮在空中,上面用绳子一拉就上去了,下面用绳子一拉就沉下去了.  </p><p>开漏,就等于输出口接了个NPN三极管,并且只接了e,b. c极 是开路的,你可以接一个电阻到3.3V,也可以接一个电阻到5V,这样,在输出1的时候,就可以是5V电压,也可以是3.3V电压了.但是不接电阻上拉的时候,这个输出高就不能实现了.  </p><p>推挽,就是有推有拉,任何时候IO口的电平都是确定的,不需要外接上拉或者下拉电阻. </p><hr><p><img src="//wangzipai.github.io/posts/33448/gpio.png" alt="gpio"></p><p>推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中,各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。输出高电平的时候，P-MOS管导通。低电平时，N-MOS管导通。两个管子轮流导通，一个负责灌电流，一个负责拉电流 ，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的供电平为0伏，高电平为3.3伏。</p><p>开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。如果我们控制输出为0，低电平，则N-MOS管导通，使输出接地。若控制输出为1，则既不输出高电平，也不输出低电平，为高阻态，需外接一个上拉电阻。他具有“线与”特性，即很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接电源的电压。若其中一个引脚为低电平，那线路就相当于短路接地，使得整个线路都为低电平，0伏。<br>开漏形式的电路有以下几个特点： </p><ol><li>利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。 </li><li>一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的沿的速度 。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。） </li><li>OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。 </li><li>可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。                                                                                                               补充：什么是“线与”？：<br> 在一个结点(线)上, 连接一个上拉电阻到电源 VCC 或 VDD 和 n 个 NPN 或 NMOS 晶体管的集电极 C 或漏极 D, 这些晶体管的发射极 E 或源极 S 都接到地线上, 只要有一个晶体管饱和, 这个结点(线)就被拉到地线电平上. 因为这些晶体管的基极注入电流(NPN)或栅极加上高电平(NMOS),晶体管就会饱和, 所以这些基极或栅极对这个结点(线)的关系是或非 NOR 逻辑. 如果这个结点后面加一个反相器, 就是或 OR 逻辑.<br> 其实可以简单的理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。 </li></ol><p>推挽输出模式一般应用在输出电平为0和3.3伏的场合。而开漏输出模式一般应用在电平不匹配的场合，如需要输出5伏的电压。</p><p>浮空输入模式在芯片内部既没有接上拉，也没有接下拉电阻，经由触发器输入。配置成这个模式直接用电压表测量其引脚电压为1点几伏，是个不确定值。由于其输入阻抗较大，一般把这种模式用于标准的通信协议如I2C，USART的接收端。由于浮空输入一般多用于外部按键输入，浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。 </p><p>上拉输入/下拉输入/模拟输入：这几个概念很好理解，从字面便能轻易读懂。 若配置为上拉输入模式，默认情况下（GPIO引脚无输入），读取的GPIO引脚数据为1，高电平。下拉输入模式则相反，在默认情况下其引脚数据为0，低电平。</p><p>模拟输入模式则关闭了施密特触发器，不接上下拉电阻，经由另一线路把电压信号传送到片上外设模块。如传送至ADC模块，由ADC模块采集电压信号。所以采用ADC外设的时候，必须使用模拟输入模式。</p><p>复用开漏输出、复用推挽输出：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）<br>最后总结下使用情况：<br>在STM32中选用IO模式<br>（1） 浮空输入_IN_FLOATING ——浮空输入，可以做KEY识别，RX1<br>（2）带上拉输入_IPU——IO内部上拉电阻输入<br>（3）带下拉输入_IPD—— IO内部下拉电阻输入<br>（4） 模拟输入_AIN ——应用ADC模拟输入，或者低功耗下省电<br>（5）开漏输出_OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能<br>（6）推挽输出_OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的<br>（7）复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA）<br>（8）复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）<br>STM32设置实例：<br>（1）模拟I2C使用开漏输出_OUT_OD，接上拉电阻，能够正确输出0和1；读值时先GPIO_SetBits(GPIOB, GPIO_Pin_0)；拉高，然后可以读IO的值；使用GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)；<br>（2）如果是无上拉电阻，IO默认是高电平；需要读取IO的值，可以使用带上拉输入_IPU和浮空输入_IN_FLOATING和开漏输出_OUT_OD；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;stm32 I/O口有8种工作模式，分别为4种输入模式和4种输出模式：&lt;/p&gt;
&lt;p&gt;4种输入模式：&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;）GPIO_Mode_AIN 模拟输入 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）GPIO_Mode_IN_FLOATING 浮空输入 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;）GPIO_Mode_IPD 下拉输入 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;）GPIO_Mode_IPU 上拉输入&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="stm32" scheme="https://wangzipai.github.io/tags/stm32/"/>
    
  </entry>
  
</feed>
